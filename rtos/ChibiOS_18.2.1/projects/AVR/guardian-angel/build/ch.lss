
build/ch.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b2  00800100  00001fda  0000206e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001fda  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000213  008001b2  008001b2  00002120  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00002120  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002134  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000820  00000000  00000000  00002178  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001ad51  00000000  00000000  00002998  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005233  00000000  00000000  0001d6e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000ebd5  00000000  00000000  0002291c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000143c  00000000  00000000  000314f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001ee3  00000000  00000000  00032930  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000076bd  00000000  00000000  00034813  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000014a0  00000000  00000000  0003bed0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	44 c0       	rjmp	.+136    	; 0x8a <__ctors_end>
       2:	00 00       	nop
       4:	5f c0       	rjmp	.+190    	; 0xc4 <__bad_interrupt>
       6:	00 00       	nop
       8:	5d c0       	rjmp	.+186    	; 0xc4 <__bad_interrupt>
       a:	00 00       	nop
       c:	5b c0       	rjmp	.+182    	; 0xc4 <__bad_interrupt>
       e:	00 00       	nop
      10:	59 c0       	rjmp	.+178    	; 0xc4 <__bad_interrupt>
      12:	00 00       	nop
      14:	57 c0       	rjmp	.+174    	; 0xc4 <__bad_interrupt>
      16:	00 00       	nop
      18:	55 c0       	rjmp	.+170    	; 0xc4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	53 c0       	rjmp	.+166    	; 0xc4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	51 c0       	rjmp	.+162    	; 0xc4 <__bad_interrupt>
      22:	00 00       	nop
      24:	4f c0       	rjmp	.+158    	; 0xc4 <__bad_interrupt>
      26:	00 00       	nop
      28:	4d c0       	rjmp	.+154    	; 0xc4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	0c 94 41 0a 	jmp	0x1482	; 0x1482 <__vector_11>
      30:	49 c0       	rjmp	.+146    	; 0xc4 <__bad_interrupt>
      32:	00 00       	nop
      34:	47 c0       	rjmp	.+142    	; 0xc4 <__bad_interrupt>
      36:	00 00       	nop
      38:	45 c0       	rjmp	.+138    	; 0xc4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	43 c0       	rjmp	.+134    	; 0xc4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	41 c0       	rjmp	.+130    	; 0xc4 <__bad_interrupt>
      42:	00 00       	nop
      44:	3f c0       	rjmp	.+126    	; 0xc4 <__bad_interrupt>
      46:	00 00       	nop
      48:	0c 94 8c 0a 	jmp	0x1518	; 0x1518 <__vector_18>
      4c:	0c 94 cd 0a 	jmp	0x159a	; 0x159a <__vector_19>
      50:	39 c0       	rjmp	.+114    	; 0xc4 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 a9 08 	jmp	0x1152	; 0x1152 <__vector_21>
      58:	35 c0       	rjmp	.+106    	; 0xc4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	33 c0       	rjmp	.+102    	; 0xc4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	31 c0       	rjmp	.+98     	; 0xc4 <__bad_interrupt>
      62:	00 00       	nop
      64:	2f c0       	rjmp	.+94     	; 0xc4 <__bad_interrupt>
	...

00000068 <__trampolines_end>:
      68:	45 46       	sbci	r20, 0x65	; 101
      6a:	47 65       	ori	r20, 0x57	; 87
      6c:	66 67       	ori	r22, 0x76	; 118
	...

0000006f <__c.2256>:
      6f:	20 2b 2d 2e 30 31 32 33 34 35 36 37 38 39 68 00      +-.0123456789h.

0000007f <__c.2391>:
      7f:	63 64 69 6e 6f 70 73 75 78 58 00                    cdinopsuxX.

0000008a <__ctors_end>:
      8a:	11 24       	eor	r1, r1
      8c:	1f be       	out	0x3f, r1	; 63
      8e:	cf ef       	ldi	r28, 0xFF	; 255
      90:	d8 e0       	ldi	r29, 0x08	; 8
      92:	de bf       	out	0x3e, r29	; 62
      94:	cd bf       	out	0x3d, r28	; 61

00000096 <__do_copy_data>:
      96:	11 e0       	ldi	r17, 0x01	; 1
      98:	a0 e0       	ldi	r26, 0x00	; 0
      9a:	b1 e0       	ldi	r27, 0x01	; 1
      9c:	ea ed       	ldi	r30, 0xDA	; 218
      9e:	ff e1       	ldi	r31, 0x1F	; 31
      a0:	02 c0       	rjmp	.+4      	; 0xa6 <__do_copy_data+0x10>
      a2:	05 90       	lpm	r0, Z+
      a4:	0d 92       	st	X+, r0
      a6:	a2 3b       	cpi	r26, 0xB2	; 178
      a8:	b1 07       	cpc	r27, r17
      aa:	d9 f7       	brne	.-10     	; 0xa2 <__do_copy_data+0xc>

000000ac <__do_clear_bss>:
      ac:	23 e0       	ldi	r18, 0x03	; 3
      ae:	a2 eb       	ldi	r26, 0xB2	; 178
      b0:	b1 e0       	ldi	r27, 0x01	; 1
      b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
      b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
      b6:	a5 3c       	cpi	r26, 0xC5	; 197
      b8:	b2 07       	cpc	r27, r18
      ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
      bc:	0e 94 b7 0b 	call	0x176e	; 0x176e <main>
      c0:	0c 94 eb 0f 	jmp	0x1fd6	; 0x1fd6 <_exit>

000000c4 <__bad_interrupt>:
      c4:	9d cf       	rjmp	.-198    	; 0x0 <__vectors>

000000c6 <_idle_thread>:
static inline void port_wait_for_interrupt(void) {

#if PORT_AVR_WFI_SLEEP_IDLE
  asm volatile ("sleep" : : : "memory");
#endif
}
      c6:	ff cf       	rjmp	.-2      	; 0xc6 <_idle_thread>

000000c8 <chSysInit>:
 *
 * @special
 */
void chSysInit(void) {

  _scheduler_init();
      c8:	f0 d1       	rcall	.+992    	; 0x4aa <_scheduler_init>
  _vt_init();
      ca:	8a d0       	rcall	.+276    	; 0x1e0 <_vt_init>
#endif
#if CH_CFG_USE_TM == TRUE
  _tm_init();
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
      cc:	a1 d4       	rcall	.+2370   	; 0xa10 <_core_init>
      ce:	df d4       	rcall	.+2494   	; 0xa8e <_heap_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
      d0:	40 e8       	ldi	r20, 0x80	; 128
      d2:	6d e1       	ldi	r22, 0x1D	; 29
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
      d4:	71 e0       	ldi	r23, 0x01	; 1
      d6:	81 e4       	ldi	r24, 0x41	; 65
      d8:	93 e0       	ldi	r25, 0x03	; 3
      da:	03 d3       	rcall	.+1542   	; 0x6e2 <_thread_init>
      dc:	fc 01       	movw	r30, r24
      de:	90 93 36 03 	sts	0x0336, r25	; 0x800336 <ch+0xc>
      e2:	80 93 35 03 	sts	0x0335, r24	; 0x800335 <ch+0xb>
      e6:	91 e0       	ldi	r25, 0x01	; 1
      e8:	95 87       	std	Z+13, r25	; 0x0d
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
      ea:	90 93 61 03 	sts	0x0361, r25	; 0x800361 <__avr_in_isr>

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
      ee:	78 94       	sei
  asm volatile ("sei" : : : "memory");
      f0:	8b e0       	ldi	r24, 0x0B	; 11
    };

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreate(&idle_descriptor);
      f2:	91 e0       	ldi	r25, 0x01	; 1
      f4:	7c c3       	rjmp	.+1784   	; 0x7ee <chThdCreate>

000000f6 <chSysTimerHandlerI>:
      f6:	cf 92       	push	r12
      f8:	df 92       	push	r13
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
      fa:	ef 92       	push	r14
      fc:	ff 92       	push	r15
      fe:	0f 93       	push	r16
     100:	1f 93       	push	r17
     102:	cf 93       	push	r28
     104:	df 93       	push	r29
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
     106:	c0 91 37 03 	lds	r28, 0x0337	; 0x800337 <ch+0xd>
     10a:	d0 91 38 03 	lds	r29, 0x0338	; 0x800338 <ch+0xe>
     10e:	4c 81       	ldd	r20, Y+4	; 0x04
     110:	5d 81       	ldd	r21, Y+5	; 0x05
     112:	87 e3       	ldi	r24, 0x37	; 55
     114:	e8 2e       	mov	r14, r24
     116:	83 e0       	ldi	r24, 0x03	; 3
     118:	f8 2e       	mov	r15, r24
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t) TCNT1;
     11a:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
     11e:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
     122:	20 91 3d 03 	lds	r18, 0x033D	; 0x80033d <ch+0x13>
     126:	30 91 3e 03 	lds	r19, 0x033E	; 0x80033e <ch+0x14>
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
     12a:	8c 01       	movw	r16, r24
     12c:	02 1b       	sub	r16, r18
     12e:	13 0b       	sbc	r17, r19

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
     130:	04 17       	cp	r16, r20
     132:	15 07       	cpc	r17, r21
     134:	90 f4       	brcc	.+36     	; 0x15a <chSysTimerHandlerI+0x64>
     136:	2a c0       	rjmp	.+84     	; 0x18c <chSysTimerHandlerI+0x96>
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
     138:	88 85       	ldd	r24, Y+8	; 0x08
     13a:	99 85       	ldd	r25, Y+9	; 0x09
     13c:	f6 01       	movw	r30, r12
     13e:	09 95       	icall
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
     140:	c0 91 37 03 	lds	r28, 0x0337	; 0x800337 <ch+0xd>
     144:	d0 91 38 03 	lds	r29, 0x0338	; 0x800338 <ch+0xe>
    }
    while (vtp->delta <= nowdelta);
     148:	4c 81       	ldd	r20, Y+4	; 0x04
     14a:	5d 81       	ldd	r21, Y+5	; 0x05
     14c:	04 17       	cp	r16, r20
     14e:	15 07       	cpc	r17, r21
     150:	20 f3       	brcs	.-56     	; 0x11a <chSysTimerHandlerI+0x24>
     152:	20 91 3d 03 	lds	r18, 0x033D	; 0x80033d <ch+0x13>
     156:	30 91 3e 03 	lds	r19, 0x033E	; 0x80033e <ch+0x14>
      ch.vtlist.lasttime += vtp->delta;
     15a:	24 0f       	add	r18, r20
     15c:	35 1f       	adc	r19, r21
     15e:	30 93 3e 03 	sts	0x033E, r19	; 0x80033e <ch+0x14>
     162:	20 93 3d 03 	sts	0x033D, r18	; 0x80033d <ch+0x13>
      nowdelta -= vtp->delta;
     166:	04 1b       	sub	r16, r20
     168:	15 0b       	sbc	r17, r21
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
     16a:	e8 81       	ld	r30, Y
     16c:	f9 81       	ldd	r31, Y+1	; 0x01
     16e:	f3 82       	std	Z+3, r15	; 0x03
     170:	e2 82       	std	Z+2, r14	; 0x02
      ch.vtlist.next = vtp->next;
     172:	f0 93 38 03 	sts	0x0338, r31	; 0x800338 <ch+0xe>
     176:	e0 93 37 03 	sts	0x0337, r30	; 0x800337 <ch+0xd>
      fn = vtp->func;
     17a:	ce 80       	ldd	r12, Y+6	; 0x06
     17c:	df 80       	ldd	r13, Y+7	; 0x07
      vtp->func = NULL;
     17e:	1f 82       	std	Y+7, r1	; 0x07
     180:	1e 82       	std	Y+6, r1	; 0x06
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
     182:	e7 53       	subi	r30, 0x37	; 55
     184:	f3 40       	sbci	r31, 0x03	; 3
     186:	c1 f6       	brne	.-80     	; 0x138 <chSysTimerHandlerI+0x42>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
     188:	d6 d4       	rcall	.+2476   	; 0xb36 <stStopAlarm>
     18a:	d6 cf       	rjmp	.-84     	; 0x138 <chSysTimerHandlerI+0x42>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
     18c:	f3 e0       	ldi	r31, 0x03	; 3
     18e:	c7 33       	cpi	r28, 0x37	; 55
     190:	df 07       	cpc	r29, r31
     192:	e9 f0       	breq	.+58     	; 0x1ce <chSysTimerHandlerI+0xd8>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
     194:	90 93 3e 03 	sts	0x033E, r25	; 0x80033e <ch+0x14>
     198:	80 93 3d 03 	sts	0x033D, r24	; 0x80033d <ch+0x13>
  ch.vtlist.next->delta -= nowdelta;
     19c:	4c 81       	ldd	r20, Y+4	; 0x04
     19e:	5d 81       	ldd	r21, Y+5	; 0x05
     1a0:	24 0f       	add	r18, r20
     1a2:	35 1f       	adc	r19, r21
     1a4:	28 1b       	sub	r18, r24
     1a6:	39 0b       	sbc	r19, r25
     1a8:	3d 83       	std	Y+5, r19	; 0x05
     1aa:	2c 83       	std	Y+4, r18	; 0x04
  return systime + (systime_t)interval;
     1ac:	22 30       	cpi	r18, 0x02	; 2
     1ae:	31 05       	cpc	r19, r1
     1b0:	58 f0       	brcs	.+22     	; 0x1c8 <chSysTimerHandlerI+0xd2>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
     1b2:	82 0f       	add	r24, r18
     1b4:	93 1f       	adc	r25, r19
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->time++;
#endif
  chVTDoTickI();
  CH_CFG_SYSTEM_TICK_HOOK();
}
     1b6:	df 91       	pop	r29
     1b8:	cf 91       	pop	r28
     1ba:	1f 91       	pop	r17
     1bc:	0f 91       	pop	r16
     1be:	ff 90       	pop	r15
     1c0:	ef 90       	pop	r14
     1c2:	df 90       	pop	r13
     1c4:	cf 90       	pop	r12
     1c6:	ba c4       	rjmp	.+2420   	; 0xb3c <stSetAlarm>
     1c8:	22 e0       	ldi	r18, 0x02	; 2
     1ca:	30 e0       	ldi	r19, 0x00	; 0
     1cc:	f2 cf       	rjmp	.-28     	; 0x1b2 <chSysTimerHandlerI+0xbc>
     1ce:	df 91       	pop	r29
     1d0:	cf 91       	pop	r28
     1d2:	1f 91       	pop	r17
     1d4:	0f 91       	pop	r16
     1d6:	ff 90       	pop	r15
     1d8:	ef 90       	pop	r14
     1da:	df 90       	pop	r13
     1dc:	cf 90       	pop	r12
     1de:	08 95       	ret

000001e0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
     1e0:	ea e2       	ldi	r30, 0x2A	; 42
     1e2:	f3 e0       	ldi	r31, 0x03	; 3
     1e4:	87 e3       	ldi	r24, 0x37	; 55
     1e6:	93 e0       	ldi	r25, 0x03	; 3
     1e8:	96 87       	std	Z+14, r25	; 0x0e
     1ea:	85 87       	std	Z+13, r24	; 0x0d
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
     1ec:	90 8b       	std	Z+16, r25	; 0x10
     1ee:	87 87       	std	Z+15, r24	; 0x0f
  ch.vtlist.delta = (sysinterval_t)-1;
     1f0:	8f ef       	ldi	r24, 0xFF	; 255
     1f2:	9f ef       	ldi	r25, 0xFF	; 255
     1f4:	92 8b       	std	Z+18, r25	; 0x12
     1f6:	81 8b       	std	Z+17, r24	; 0x11
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
     1f8:	14 8a       	std	Z+20, r1	; 0x14
     1fa:	13 8a       	std	Z+19, r1	; 0x13
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     1fc:	08 95       	ret

000001fe <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
     1fe:	ef 92       	push	r14
     200:	ff 92       	push	r15
     202:	0f 93       	push	r16
     204:	1f 93       	push	r17
     206:	cf 93       	push	r28
     208:	df 93       	push	r29
     20a:	7c 01       	movw	r14, r24
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
     20c:	dc 01       	movw	r26, r24
     20e:	19 96       	adiw	r26, 0x09	; 9
     210:	3c 93       	st	X, r19
     212:	2e 93       	st	-X, r18
     214:	18 97       	sbiw	r26, 0x08	; 8
  vtp->func = vtfunc;
     216:	17 96       	adiw	r26, 0x07	; 7
     218:	5c 93       	st	X, r21
     21a:	4e 93       	st	-X, r20
     21c:	16 97       	sbiw	r26, 0x06	; 6
     21e:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
     222:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
     226:	eb 01       	movw	r28, r22
     228:	62 30       	cpi	r22, 0x02	; 2
     22a:	71 05       	cpc	r23, r1
     22c:	10 f4       	brcc	.+4      	; 0x232 <chVTDoSetI+0x34>
     22e:	c2 e0       	ldi	r28, 0x02	; 2
     230:	d0 e0       	ldi	r29, 0x00	; 0
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
     232:	00 91 37 03 	lds	r16, 0x0337	; 0x800337 <ch+0xd>
     236:	10 91 38 03 	lds	r17, 0x0338	; 0x800338 <ch+0xe>
     23a:	b3 e0       	ldi	r27, 0x03	; 3
     23c:	07 33       	cpi	r16, 0x37	; 55
     23e:	1b 07       	cpc	r17, r27
     240:	09 f4       	brne	.+2      	; 0x244 <chVTDoSetI+0x46>
     242:	5c c0       	rjmp	.+184    	; 0x2fc <chVTDoSetI+0xfe>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
     244:	40 91 3d 03 	lds	r20, 0x033D	; 0x80033d <ch+0x13>
     248:	50 91 3e 03 	lds	r21, 0x033E	; 0x80033e <ch+0x14>
  return (sysinterval_t)((systime_t)(end - start));
     24c:	84 1b       	sub	r24, r20
     24e:	95 0b       	sbc	r25, r21
     250:	c8 0f       	add	r28, r24
     252:	d9 1f       	adc	r29, r25
     254:	d8 01       	movw	r26, r16
     256:	14 96       	adiw	r26, 0x04	; 4
     258:	2d 91       	ld	r18, X+
     25a:	3c 91       	ld	r19, X
     25c:	15 97       	sbiw	r26, 0x05	; 5

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
     25e:	c8 17       	cp	r28, r24
     260:	d9 07       	cpc	r29, r25
     262:	d8 f1       	brcs	.+118    	; 0x2da <chVTDoSetI+0xdc>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
     264:	c2 17       	cp	r28, r18
     266:	d3 07       	cpc	r29, r19
     268:	08 f4       	brcc	.+2      	; 0x26c <chVTDoSetI+0x6e>
     26a:	3f c0       	rjmp	.+126    	; 0x2ea <chVTDoSetI+0xec>
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
     26c:	2c 17       	cp	r18, r28
     26e:	3d 07       	cpc	r19, r29
     270:	60 f4       	brcc	.+24     	; 0x28a <chVTDoSetI+0x8c>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
     272:	c2 1b       	sub	r28, r18
     274:	d3 0b       	sbc	r29, r19
    p = p->next;
     276:	f8 01       	movw	r30, r16
     278:	00 81       	ld	r16, Z
     27a:	11 81       	ldd	r17, Z+1	; 0x01
  while (p->delta < delta) {
     27c:	d8 01       	movw	r26, r16
     27e:	14 96       	adiw	r26, 0x04	; 4
     280:	2d 91       	ld	r18, X+
     282:	3c 91       	ld	r19, X
     284:	2c 17       	cp	r18, r28
     286:	3d 07       	cpc	r19, r29
     288:	a0 f3       	brcs	.-24     	; 0x272 <chVTDoSetI+0x74>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
     28a:	f7 01       	movw	r30, r14
     28c:	11 83       	std	Z+1, r17	; 0x01
     28e:	00 83       	st	Z, r16
  vtp->prev = vtp->next->prev;
     290:	d8 01       	movw	r26, r16
     292:	12 96       	adiw	r26, 0x02	; 2
     294:	ed 91       	ld	r30, X+
     296:	fc 91       	ld	r31, X
     298:	d7 01       	movw	r26, r14
     29a:	13 96       	adiw	r26, 0x03	; 3
     29c:	fc 93       	st	X, r31
     29e:	ee 93       	st	-X, r30
     2a0:	12 97       	sbiw	r26, 0x02	; 2
  vtp->prev->next = vtp;
     2a2:	f1 82       	std	Z+1, r15	; 0x01
     2a4:	e0 82       	st	Z, r14
  p->prev = vtp;
     2a6:	f8 01       	movw	r30, r16
     2a8:	f3 82       	std	Z+3, r15	; 0x03
     2aa:	e2 82       	std	Z+2, r14	; 0x02
  vtp->delta = delta;
     2ac:	15 96       	adiw	r26, 0x05	; 5
     2ae:	dc 93       	st	X, r29
     2b0:	ce 93       	st	-X, r28
     2b2:	14 97       	sbiw	r26, 0x04	; 4

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
     2b4:	84 81       	ldd	r24, Z+4	; 0x04
     2b6:	95 81       	ldd	r25, Z+5	; 0x05
     2b8:	8c 1b       	sub	r24, r28
     2ba:	9d 0b       	sbc	r25, r29
     2bc:	95 83       	std	Z+5, r25	; 0x05
     2be:	84 83       	std	Z+4, r24	; 0x04

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
     2c0:	8f ef       	ldi	r24, 0xFF	; 255
     2c2:	9f ef       	ldi	r25, 0xFF	; 255
     2c4:	90 93 3c 03 	sts	0x033C, r25	; 0x80033c <ch+0x12>
     2c8:	80 93 3b 03 	sts	0x033B, r24	; 0x80033b <ch+0x11>
}
     2cc:	df 91       	pop	r29
     2ce:	cf 91       	pop	r28
     2d0:	1f 91       	pop	r17
     2d2:	0f 91       	pop	r16
     2d4:	ff 90       	pop	r15
     2d6:	ef 90       	pop	r14
     2d8:	08 95       	ret
      delta -= p->delta;
     2da:	c2 1b       	sub	r28, r18
     2dc:	d3 0b       	sbc	r29, r19
      p = p->next;
     2de:	0d 91       	ld	r16, X+
     2e0:	1c 91       	ld	r17, X
     2e2:	f8 01       	movw	r30, r16
     2e4:	24 81       	ldd	r18, Z+4	; 0x04
     2e6:	35 81       	ldd	r19, Z+5	; 0x05
     2e8:	c1 cf       	rjmp	.-126    	; 0x26c <chVTDoSetI+0x6e>
     2ea:	ca 01       	movw	r24, r20
     2ec:	8c 0f       	add	r24, r28
     2ee:	9d 1f       	adc	r25, r29
     2f0:	25 d4       	rcall	.+2122   	; 0xb3c <stSetAlarm>
     2f2:	d8 01       	movw	r26, r16
     2f4:	14 96       	adiw	r26, 0x04	; 4
     2f6:	2d 91       	ld	r18, X+
     2f8:	3c 91       	ld	r19, X
     2fa:	b8 cf       	rjmp	.-144    	; 0x26c <chVTDoSetI+0x6e>
      ch.vtlist.lasttime = now;
     2fc:	90 93 3e 03 	sts	0x033E, r25	; 0x80033e <ch+0x14>
     300:	80 93 3d 03 	sts	0x033D, r24	; 0x80033d <ch+0x13>
      ch.vtlist.next = vtp;
     304:	f0 92 38 03 	sts	0x0338, r15	; 0x800338 <ch+0xe>
     308:	e0 92 37 03 	sts	0x0337, r14	; 0x800337 <ch+0xd>
      ch.vtlist.prev = vtp;
     30c:	f0 92 3a 03 	sts	0x033A, r15	; 0x80033a <ch+0x10>
     310:	e0 92 39 03 	sts	0x0339, r14	; 0x800339 <ch+0xf>
      vtp->next = (virtual_timer_t *)&ch.vtlist;
     314:	f7 01       	movw	r30, r14
     316:	11 83       	std	Z+1, r17	; 0x01
     318:	00 83       	st	Z, r16
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
     31a:	13 83       	std	Z+3, r17	; 0x03
     31c:	02 83       	std	Z+2, r16	; 0x02
      vtp->delta = delay;
     31e:	d5 83       	std	Z+5, r29	; 0x05
     320:	c4 83       	std	Z+4, r28	; 0x04
  stStartAlarm(time);
     322:	8c 0f       	add	r24, r28
     324:	9d 1f       	adc	r25, r29
}
     326:	df 91       	pop	r29
     328:	cf 91       	pop	r28
     32a:	1f 91       	pop	r17
     32c:	0f 91       	pop	r16
     32e:	ff 90       	pop	r15
     330:	ef 90       	pop	r14
     332:	f8 c3       	rjmp	.+2032   	; 0xb24 <stStartAlarm>

00000334 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
     334:	cf 93       	push	r28
     336:	df 93       	push	r29
     338:	fc 01       	movw	r30, r24
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
     33a:	a0 81       	ld	r26, Z
     33c:	b1 81       	ldd	r27, Z+1	; 0x01
     33e:	c0 91 37 03 	lds	r28, 0x0337	; 0x800337 <ch+0xd>
     342:	d0 91 38 03 	lds	r29, 0x0338	; 0x800338 <ch+0xe>
     346:	c8 17       	cp	r28, r24
     348:	d9 07       	cpc	r29, r25
     34a:	f9 f0       	breq	.+62     	; 0x38a <chVTDoResetI+0x56>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
     34c:	c2 81       	ldd	r28, Z+2	; 0x02
     34e:	d3 81       	ldd	r29, Z+3	; 0x03
     350:	b9 83       	std	Y+1, r27	; 0x01
     352:	a8 83       	st	Y, r26
    vtp->next->prev = vtp->prev;
     354:	a0 81       	ld	r26, Z
     356:	b1 81       	ldd	r27, Z+1	; 0x01
     358:	13 96       	adiw	r26, 0x03	; 3
     35a:	dc 93       	st	X, r29
     35c:	ce 93       	st	-X, r28
     35e:	12 97       	sbiw	r26, 0x02	; 2
    vtp->func = NULL;
     360:	17 82       	std	Z+7, r1	; 0x07
     362:	16 82       	std	Z+6, r1	; 0x06

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
     364:	83 e0       	ldi	r24, 0x03	; 3
     366:	a7 33       	cpi	r26, 0x37	; 55
     368:	b8 07       	cpc	r27, r24
     36a:	61 f0       	breq	.+24     	; 0x384 <chVTDoResetI+0x50>
      vtp->next->delta += vtp->delta;
     36c:	14 96       	adiw	r26, 0x04	; 4
     36e:	8d 91       	ld	r24, X+
     370:	9c 91       	ld	r25, X
     372:	15 97       	sbiw	r26, 0x05	; 5
     374:	24 81       	ldd	r18, Z+4	; 0x04
     376:	35 81       	ldd	r19, Z+5	; 0x05
     378:	82 0f       	add	r24, r18
     37a:	93 1f       	adc	r25, r19
     37c:	15 96       	adiw	r26, 0x05	; 5
     37e:	9c 93       	st	X, r25
     380:	8e 93       	st	-X, r24
     382:	14 97       	sbiw	r26, 0x04	; 4
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
     384:	df 91       	pop	r29
     386:	cf 91       	pop	r28
     388:	08 95       	ret
  ch.vtlist.next = vtp->next;
     38a:	b0 93 38 03 	sts	0x0338, r27	; 0x800338 <ch+0xe>
     38e:	a0 93 37 03 	sts	0x0337, r26	; 0x800337 <ch+0xd>
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
     392:	87 e3       	ldi	r24, 0x37	; 55
     394:	93 e0       	ldi	r25, 0x03	; 3
     396:	13 96       	adiw	r26, 0x03	; 3
     398:	9c 93       	st	X, r25
     39a:	8e 93       	st	-X, r24
     39c:	12 97       	sbiw	r26, 0x02	; 2
  vtp->func = NULL;
     39e:	1f 82       	std	Y+7, r1	; 0x07
     3a0:	1e 82       	std	Y+6, r1	; 0x06
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
     3a2:	a8 17       	cp	r26, r24
     3a4:	b9 07       	cpc	r27, r25
     3a6:	79 f1       	breq	.+94     	; 0x406 <__FUSE_REGION_LENGTH__+0x6>
  ch.vtlist.next->delta += vtp->delta;
     3a8:	14 96       	adiw	r26, 0x04	; 4
     3aa:	8d 91       	ld	r24, X+
     3ac:	9c 91       	ld	r25, X
     3ae:	15 97       	sbiw	r26, 0x05	; 5
     3b0:	2c 81       	ldd	r18, Y+4	; 0x04
     3b2:	3d 81       	ldd	r19, Y+5	; 0x05
     3b4:	82 0f       	add	r24, r18
     3b6:	93 1f       	adc	r25, r19
     3b8:	15 96       	adiw	r26, 0x05	; 5
     3ba:	9c 93       	st	X, r25
     3bc:	8e 93       	st	-X, r24
     3be:	14 97       	sbiw	r26, 0x04	; 4
     3c0:	40 91 84 00 	lds	r20, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
     3c4:	50 91 85 00 	lds	r21, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
     3c8:	20 91 3d 03 	lds	r18, 0x033D	; 0x80033d <ch+0x13>
     3cc:	30 91 3e 03 	lds	r19, 0x033E	; 0x80033e <ch+0x14>
     3d0:	ba 01       	movw	r22, r20
     3d2:	62 1b       	sub	r22, r18
     3d4:	73 0b       	sbc	r23, r19
  if (nowdelta >= ch.vtlist.next->delta) {
     3d6:	68 17       	cp	r22, r24
     3d8:	79 07       	cpc	r23, r25
     3da:	a0 f6       	brcc	.-88     	; 0x384 <chVTDoResetI+0x50>
  delta = ch.vtlist.next->delta - nowdelta;
     3dc:	f9 01       	movw	r30, r18
     3de:	e4 1b       	sub	r30, r20
     3e0:	f5 0b       	sbc	r31, r21
     3e2:	af 01       	movw	r20, r30
     3e4:	48 0f       	add	r20, r24
     3e6:	59 1f       	adc	r21, r25
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
     3e8:	42 30       	cpi	r20, 0x02	; 2
     3ea:	51 05       	cpc	r21, r1
     3ec:	28 f0       	brcs	.+10     	; 0x3f8 <chVTDoResetI+0xc4>
  stSetAlarm(time);
     3ee:	82 0f       	add	r24, r18
     3f0:	93 1f       	adc	r25, r19
}
     3f2:	df 91       	pop	r29
     3f4:	cf 91       	pop	r28
     3f6:	a2 c3       	rjmp	.+1860   	; 0xb3c <stSetAlarm>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
     3f8:	cb 01       	movw	r24, r22
     3fa:	02 96       	adiw	r24, 0x02	; 2
     3fc:	82 0f       	add	r24, r18
     3fe:	93 1f       	adc	r25, r19
}
     400:	df 91       	pop	r29
     402:	cf 91       	pop	r28
     404:	9b c3       	rjmp	.+1846   	; 0xb3c <stSetAlarm>
     406:	df 91       	pop	r29
  stStopAlarm();
     408:	cf 91       	pop	r28
     40a:	95 c3       	rjmp	.+1834   	; 0xb36 <stStopAlarm>

0000040c <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
     40c:	cf 93       	push	r28
     40e:	df 93       	push	r29
     410:	dc 01       	movw	r26, r24
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
     412:	1d 96       	adiw	r26, 0x0d	; 13
     414:	8c 91       	ld	r24, X
     416:	1d 97       	sbiw	r26, 0x0d	; 13
     418:	84 30       	cpi	r24, 0x04	; 4
     41a:	d9 f1       	breq	.+118    	; 0x492 <wakeup+0x86>
     41c:	70 f5       	brcc	.+92     	; 0x47a <wakeup+0x6e>
     41e:	88 23       	and	r24, r24
     420:	49 f1       	breq	.+82     	; 0x474 <wakeup+0x68>
     422:	83 30       	cpi	r24, 0x03	; 3
     424:	31 f4       	brne	.+12     	; 0x432 <wakeup+0x26>
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
     426:	50 96       	adiw	r26, 0x10	; 16
     428:	ed 91       	ld	r30, X+
     42a:	fc 91       	ld	r31, X
     42c:	51 97       	sbiw	r26, 0x11	; 17
     42e:	11 82       	std	Z+1, r1	; 0x01
     430:	10 82       	st	Z, r1
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
     432:	8f ef       	ldi	r24, 0xFF	; 255
     434:	9f ef       	ldi	r25, 0xFF	; 255
     436:	51 96       	adiw	r26, 0x11	; 17
     438:	9c 93       	st	X, r25
     43a:	8e 93       	st	-X, r24
     43c:	50 97       	sbiw	r26, 0x10	; 16
  tp->state = CH_STATE_READY;
     43e:	1d 96       	adiw	r26, 0x0d	; 13
     440:	1c 92       	st	X, r1
     442:	1d 97       	sbiw	r26, 0x0d	; 13
  } while (cp->prio >= tp->prio);
     444:	14 96       	adiw	r26, 0x04	; 4
     446:	8c 91       	ld	r24, X
     448:	14 97       	sbiw	r26, 0x04	; 4
  cp = (thread_t *)&ch.rlist.queue;
     44a:	ea e2       	ldi	r30, 0x2A	; 42
     44c:	f3 e0       	ldi	r31, 0x03	; 3
    cp = cp->queue.next;
     44e:	01 90       	ld	r0, Z+
     450:	f0 81       	ld	r31, Z
     452:	e0 2d       	mov	r30, r0
  } while (cp->prio >= tp->prio);
     454:	94 81       	ldd	r25, Z+4	; 0x04
     456:	98 17       	cp	r25, r24
     458:	d0 f7       	brcc	.-12     	; 0x44e <wakeup+0x42>
  tp->queue.next             = cp;
     45a:	11 96       	adiw	r26, 0x01	; 1
     45c:	fc 93       	st	X, r31
     45e:	ee 93       	st	-X, r30
  tp->queue.prev             = cp->queue.prev;
     460:	c2 81       	ldd	r28, Z+2	; 0x02
     462:	d3 81       	ldd	r29, Z+3	; 0x03
     464:	13 96       	adiw	r26, 0x03	; 3
     466:	dc 93       	st	X, r29
     468:	ce 93       	st	-X, r28
     46a:	12 97       	sbiw	r26, 0x02	; 2
  tp->queue.prev->queue.next = tp;
     46c:	b9 83       	std	Y+1, r27	; 0x01
     46e:	a8 83       	st	Y, r26
  cp->queue.prev             = tp;
     470:	b3 83       	std	Z+3, r27	; 0x03
     472:	a2 83       	std	Z+2, r26	; 0x02
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	08 95       	ret
     47a:	85 30       	cpi	r24, 0x05	; 5
     47c:	41 f4       	brne	.+16     	; 0x48e <wakeup+0x82>
    chSemFastSignalI(tp->u.wtsemp);
     47e:	50 96       	adiw	r26, 0x10	; 16
     480:	ed 91       	ld	r30, X+
     482:	fc 91       	ld	r31, X
     484:	51 97       	sbiw	r26, 0x11	; 17
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
     486:	84 81       	ldd	r24, Z+4	; 0x04
     488:	8f 5f       	subi	r24, 0xFF	; 255
     48a:	84 83       	std	Z+4, r24	; 0x04
     48c:	02 c0       	rjmp	.+4      	; 0x492 <wakeup+0x86>
     48e:	87 30       	cpi	r24, 0x07	; 7
     490:	81 f6       	brne	.-96     	; 0x432 <wakeup+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
     492:	12 96       	adiw	r26, 0x02	; 2
     494:	cd 91       	ld	r28, X+
     496:	dc 91       	ld	r29, X
     498:	13 97       	sbiw	r26, 0x03	; 3
     49a:	ed 91       	ld	r30, X+
     49c:	fc 91       	ld	r31, X
     49e:	11 97       	sbiw	r26, 0x01	; 1
     4a0:	f9 83       	std	Y+1, r31	; 0x01
     4a2:	e8 83       	st	Y, r30
  tp->queue.next->queue.prev = tp->queue.prev;
     4a4:	d3 83       	std	Z+3, r29	; 0x03
     4a6:	c2 83       	std	Z+2, r28	; 0x02

  return tp;
     4a8:	c4 cf       	rjmp	.-120    	; 0x432 <wakeup+0x26>

000004aa <_scheduler_init>:
  tqp->next = (thread_t *)tqp;
     4aa:	ea e2       	ldi	r30, 0x2A	; 42
     4ac:	f3 e0       	ldi	r31, 0x03	; 3
     4ae:	f1 83       	std	Z+1, r31	; 0x01
     4b0:	e0 83       	st	Z, r30
  tqp->prev = (thread_t *)tqp;
     4b2:	f3 83       	std	Z+3, r31	; 0x03
     4b4:	e2 83       	std	Z+2, r30	; 0x02
  ch.rlist.prio = NOPRIO;
     4b6:	14 82       	std	Z+4, r1	; 0x04
  ch.rlist.newer = (thread_t *)&ch.rlist;
     4b8:	f0 87       	std	Z+8, r31	; 0x08
     4ba:	e7 83       	std	Z+7, r30	; 0x07
  ch.rlist.older = (thread_t *)&ch.rlist;
     4bc:	f2 87       	std	Z+10, r31	; 0x0a
     4be:	e1 87       	std	Z+9, r30	; 0x09
}
     4c0:	08 95       	ret

000004c2 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
     4c2:	cf 93       	push	r28
     4c4:	df 93       	push	r29
     4c6:	dc 01       	movw	r26, r24
  tp->state = CH_STATE_READY;
     4c8:	1d 96       	adiw	r26, 0x0d	; 13
     4ca:	1c 92       	st	X, r1
     4cc:	1d 97       	sbiw	r26, 0x0d	; 13
  } while (cp->prio >= tp->prio);
     4ce:	14 96       	adiw	r26, 0x04	; 4
     4d0:	2c 91       	ld	r18, X
     4d2:	14 97       	sbiw	r26, 0x04	; 4
  cp = (thread_t *)&ch.rlist.queue;
     4d4:	ea e2       	ldi	r30, 0x2A	; 42
     4d6:	f3 e0       	ldi	r31, 0x03	; 3
    cp = cp->queue.next;
     4d8:	01 90       	ld	r0, Z+
     4da:	f0 81       	ld	r31, Z
     4dc:	e0 2d       	mov	r30, r0
  } while (cp->prio >= tp->prio);
     4de:	94 81       	ldd	r25, Z+4	; 0x04
     4e0:	92 17       	cp	r25, r18
     4e2:	d0 f7       	brcc	.-12     	; 0x4d8 <chSchReadyI+0x16>
  tp->queue.next             = cp;
     4e4:	11 96       	adiw	r26, 0x01	; 1
     4e6:	fc 93       	st	X, r31
     4e8:	ee 93       	st	-X, r30
  tp->queue.prev             = cp->queue.prev;
     4ea:	c2 81       	ldd	r28, Z+2	; 0x02
     4ec:	d3 81       	ldd	r29, Z+3	; 0x03
     4ee:	13 96       	adiw	r26, 0x03	; 3
     4f0:	dc 93       	st	X, r29
     4f2:	ce 93       	st	-X, r28
     4f4:	12 97       	sbiw	r26, 0x02	; 2
  tp->queue.prev->queue.next = tp;
     4f6:	b9 83       	std	Y+1, r27	; 0x01
     4f8:	a8 83       	st	Y, r26
  cp->queue.prev             = tp;
     4fa:	b3 83       	std	Z+3, r27	; 0x03
     4fc:	a2 83       	std	Z+2, r26	; 0x02
}
     4fe:	cd 01       	movw	r24, r26
     500:	df 91       	pop	r29
     502:	cf 91       	pop	r28
     504:	08 95       	ret

00000506 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
     506:	cf 93       	push	r28
     508:	df 93       	push	r29
  thread_t *otp = currp;
     50a:	ea e2       	ldi	r30, 0x2A	; 42
     50c:	f3 e0       	ldi	r31, 0x03	; 3
     50e:	63 85       	ldd	r22, Z+11	; 0x0b
     510:	74 85       	ldd	r23, Z+12	; 0x0c
  otp->state = newstate;
     512:	db 01       	movw	r26, r22
     514:	1d 96       	adiw	r26, 0x0d	; 13
     516:	8c 93       	st	X, r24
  thread_t *tp = tqp->next;
     518:	80 81       	ld	r24, Z
     51a:	91 81       	ldd	r25, Z+1	; 0x01
  tqp->next             = tp->queue.next;
     51c:	ec 01       	movw	r28, r24
     51e:	a8 81       	ld	r26, Y
     520:	b9 81       	ldd	r27, Y+1	; 0x01
     522:	b1 83       	std	Z+1, r27	; 0x01
     524:	a0 83       	st	Z, r26
  tqp->next->queue.prev = (thread_t *)tqp;
     526:	13 96       	adiw	r26, 0x03	; 3
     528:	fc 93       	st	X, r31
     52a:	ee 93       	st	-X, r30
     52c:	12 97       	sbiw	r26, 0x02	; 2
  currp = queue_fifo_remove(&ch.rlist.queue);
     52e:	94 87       	std	Z+12, r25	; 0x0c
     530:	83 87       	std	Z+11, r24	; 0x0b
  currp->state = CH_STATE_CURRENT;
     532:	21 e0       	ldi	r18, 0x01	; 1
     534:	2d 87       	std	Y+13, r18	; 0x0d
  chSysSwitch(currp, otp);
     536:	b8 d2       	rcall	.+1392   	; 0xaa8 <_port_switch>
}
     538:	df 91       	pop	r29
     53a:	cf 91       	pop	r28
     53c:	08 95       	ret

0000053e <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
     53e:	1f 93       	push	r17
     540:	cf 93       	push	r28
     542:	df 93       	push	r29
     544:	cd b7       	in	r28, 0x3d	; 61
     546:	de b7       	in	r29, 0x3e	; 62
     548:	2a 97       	sbiw	r28, 0x0a	; 10
     54a:	0f b6       	in	r0, 0x3f	; 63
     54c:	f8 94       	cli
     54e:	de bf       	out	0x3e, r29	; 62
     550:	0f be       	out	0x3f, r0	; 63
     552:	cd bf       	out	0x3d, r28	; 61
     554:	18 2f       	mov	r17, r24

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
     556:	6f 3f       	cpi	r22, 0xFF	; 255
     558:	76 07       	cpc	r23, r22
     55a:	11 f1       	breq	.+68     	; 0x5a0 <chSchGoSleepTimeoutS+0x62>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
     55c:	20 91 35 03 	lds	r18, 0x0335	; 0x800335 <ch+0xb>
     560:	30 91 36 03 	lds	r19, 0x0336	; 0x800336 <ch+0xc>
     564:	46 e0       	ldi	r20, 0x06	; 6
     566:	52 e0       	ldi	r21, 0x02	; 2
     568:	ce 01       	movw	r24, r28
     56a:	01 96       	adiw	r24, 0x01	; 1
     56c:	48 de       	rcall	.-880    	; 0x1fe <chVTDoSetI>
    chSchGoSleepS(newstate);
     56e:	81 2f       	mov	r24, r17
     570:	ca df       	rcall	.-108    	; 0x506 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
     572:	8f 81       	ldd	r24, Y+7	; 0x07
     574:	98 85       	ldd	r25, Y+8	; 0x08
     576:	89 2b       	or	r24, r25
     578:	19 f0       	breq	.+6      	; 0x580 <chSchGoSleepTimeoutS+0x42>
      chVTDoResetI(&vt);
     57a:	ce 01       	movw	r24, r28
     57c:	01 96       	adiw	r24, 0x01	; 1
     57e:	da de       	rcall	.-588    	; 0x334 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
     580:	e0 91 35 03 	lds	r30, 0x0335	; 0x800335 <ch+0xb>
     584:	f0 91 36 03 	lds	r31, 0x0336	; 0x800336 <ch+0xc>
}
     588:	80 89       	ldd	r24, Z+16	; 0x10
     58a:	91 89       	ldd	r25, Z+17	; 0x11
     58c:	2a 96       	adiw	r28, 0x0a	; 10
     58e:	0f b6       	in	r0, 0x3f	; 63
     590:	f8 94       	cli
     592:	de bf       	out	0x3e, r29	; 62
     594:	0f be       	out	0x3f, r0	; 63
     596:	cd bf       	out	0x3d, r28	; 61
     598:	df 91       	pop	r29
     59a:	cf 91       	pop	r28
     59c:	1f 91       	pop	r17
    chSchGoSleepS(newstate);
     59e:	08 95       	ret
     5a0:	81 2f       	mov	r24, r17
     5a2:	b1 df       	rcall	.-158    	; 0x506 <chSchGoSleepS>
     5a4:	ed cf       	rjmp	.-38     	; 0x580 <chSchGoSleepTimeoutS+0x42>

000005a6 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	dc 01       	movw	r26, r24
  thread_t *otp = currp;
     5ac:	40 91 35 03 	lds	r20, 0x0335	; 0x800335 <ch+0xb>
     5b0:	50 91 36 03 	lds	r21, 0x0336	; 0x800336 <ch+0xc>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
     5b4:	51 96       	adiw	r26, 0x11	; 17
     5b6:	7c 93       	st	X, r23
     5b8:	6e 93       	st	-X, r22
     5ba:	50 97       	sbiw	r26, 0x10	; 16

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
     5bc:	14 96       	adiw	r26, 0x04	; 4
     5be:	2c 91       	ld	r18, X
     5c0:	14 97       	sbiw	r26, 0x04	; 4
     5c2:	ea 01       	movw	r28, r20
     5c4:	8c 81       	ldd	r24, Y+4	; 0x04
     5c6:	82 17       	cp	r24, r18
     5c8:	d8 f0       	brcs	.+54     	; 0x600 <chSchWakeupS+0x5a>
  tp->state = CH_STATE_READY;
     5ca:	1d 96       	adiw	r26, 0x0d	; 13
     5cc:	1c 92       	st	X, r1
     5ce:	1d 97       	sbiw	r26, 0x0d	; 13
  cp = (thread_t *)&ch.rlist.queue;
     5d0:	ea e2       	ldi	r30, 0x2A	; 42
     5d2:	f3 e0       	ldi	r31, 0x03	; 3
    cp = cp->queue.next;
     5d4:	01 90       	ld	r0, Z+
     5d6:	f0 81       	ld	r31, Z
     5d8:	e0 2d       	mov	r30, r0
  } while (cp->prio >= tp->prio);
     5da:	94 81       	ldd	r25, Z+4	; 0x04
     5dc:	92 17       	cp	r25, r18
     5de:	d0 f7       	brcc	.-12     	; 0x5d4 <chSchWakeupS+0x2e>
  tp->queue.next             = cp;
     5e0:	11 96       	adiw	r26, 0x01	; 1
     5e2:	fc 93       	st	X, r31
     5e4:	ee 93       	st	-X, r30
  tp->queue.prev             = cp->queue.prev;
     5e6:	c2 81       	ldd	r28, Z+2	; 0x02
     5e8:	d3 81       	ldd	r29, Z+3	; 0x03
     5ea:	13 96       	adiw	r26, 0x03	; 3
     5ec:	dc 93       	st	X, r29
     5ee:	ce 93       	st	-X, r28
     5f0:	12 97       	sbiw	r26, 0x02	; 2
  tp->queue.prev->queue.next = tp;
     5f2:	b9 83       	std	Y+1, r27	; 0x01
     5f4:	a8 83       	st	Y, r26
  cp->queue.prev             = tp;
     5f6:	b3 83       	std	Z+3, r27	; 0x03
     5f8:	a2 83       	std	Z+2, r26	; 0x02
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
     5fa:	df 91       	pop	r29
     5fc:	cf 91       	pop	r28
     5fe:	08 95       	ret
  tp->state = CH_STATE_READY;
     600:	1d 86       	std	Y+13, r1	; 0x0d
  cp = (thread_t *)&ch.rlist.queue;
     602:	ea e2       	ldi	r30, 0x2A	; 42
     604:	f3 e0       	ldi	r31, 0x03	; 3
    cp = cp->queue.next;
     606:	01 90       	ld	r0, Z+
     608:	f0 81       	ld	r31, Z
     60a:	e0 2d       	mov	r30, r0
  } while (cp->prio >= tp->prio);
     60c:	94 81       	ldd	r25, Z+4	; 0x04
     60e:	98 17       	cp	r25, r24
     610:	d0 f7       	brcc	.-12     	; 0x606 <chSchWakeupS+0x60>
  tp->queue.next             = cp;
     612:	ea 01       	movw	r28, r20
     614:	f9 83       	std	Y+1, r31	; 0x01
     616:	e8 83       	st	Y, r30
  tp->queue.prev             = cp->queue.prev;
     618:	82 81       	ldd	r24, Z+2	; 0x02
     61a:	93 81       	ldd	r25, Z+3	; 0x03
     61c:	9b 83       	std	Y+3, r25	; 0x03
     61e:	8a 83       	std	Y+2, r24	; 0x02
  tp->queue.prev->queue.next = tp;
     620:	ec 01       	movw	r28, r24
     622:	59 83       	std	Y+1, r21	; 0x01
     624:	48 83       	st	Y, r20
  cp->queue.prev             = tp;
     626:	53 83       	std	Z+3, r21	; 0x03
     628:	42 83       	std	Z+2, r20	; 0x02
    currp = ntp;
     62a:	b0 93 36 03 	sts	0x0336, r27	; 0x800336 <ch+0xc>
     62e:	a0 93 35 03 	sts	0x0335, r26	; 0x800335 <ch+0xb>
    ntp->state = CH_STATE_CURRENT;
     632:	81 e0       	ldi	r24, 0x01	; 1
     634:	1d 96       	adiw	r26, 0x0d	; 13
     636:	8c 93       	st	X, r24
     638:	1d 97       	sbiw	r26, 0x0d	; 13
    chSysSwitch(ntp, otp);
     63a:	ba 01       	movw	r22, r20
     63c:	cd 01       	movw	r24, r26
     63e:	34 d2       	rcall	.+1128   	; 0xaa8 <_port_switch>
}
     640:	df 91       	pop	r29
     642:	cf 91       	pop	r28
     644:	08 95       	ret

00000646 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
     646:	a0 91 2a 03 	lds	r26, 0x032A	; 0x80032a <ch>
     64a:	b0 91 2b 03 	lds	r27, 0x032B	; 0x80032b <ch+0x1>
  tprio_t p2 = currp->prio;
     64e:	e0 91 35 03 	lds	r30, 0x0335	; 0x800335 <ch+0xb>
     652:	f0 91 36 03 	lds	r31, 0x0336	; 0x800336 <ch+0xc>
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
     656:	81 e0       	ldi	r24, 0x01	; 1
     658:	14 96       	adiw	r26, 0x04	; 4
     65a:	2c 91       	ld	r18, X
     65c:	94 81       	ldd	r25, Z+4	; 0x04
     65e:	92 17       	cp	r25, r18
     660:	08 f0       	brcs	.+2      	; 0x664 <chSchIsPreemptionRequired+0x1e>
     662:	80 e0       	ldi	r24, 0x00	; 0
#endif
}
     664:	08 95       	ret

00000666 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
     666:	cf 93       	push	r28
     668:	df 93       	push	r29
  thread_t *otp = currp;
     66a:	a0 91 35 03 	lds	r26, 0x0335	; 0x800335 <ch+0xb>
     66e:	b0 91 36 03 	lds	r27, 0x0336	; 0x800336 <ch+0xc>
  thread_t *tp = tqp->next;
     672:	40 91 2a 03 	lds	r20, 0x032A	; 0x80032a <ch>
     676:	50 91 2b 03 	lds	r21, 0x032B	; 0x80032b <ch+0x1>
  tqp->next             = tp->queue.next;
     67a:	ea 01       	movw	r28, r20
     67c:	e8 81       	ld	r30, Y
     67e:	f9 81       	ldd	r31, Y+1	; 0x01
     680:	f0 93 2b 03 	sts	0x032B, r31	; 0x80032b <ch+0x1>
     684:	e0 93 2a 03 	sts	0x032A, r30	; 0x80032a <ch>
  tqp->next->queue.prev = (thread_t *)tqp;
     688:	8a e2       	ldi	r24, 0x2A	; 42
     68a:	93 e0       	ldi	r25, 0x03	; 3
     68c:	93 83       	std	Z+3, r25	; 0x03
     68e:	82 83       	std	Z+2, r24	; 0x02

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
     690:	50 93 36 03 	sts	0x0336, r21	; 0x800336 <ch+0xc>
     694:	40 93 35 03 	sts	0x0335, r20	; 0x800335 <ch+0xb>
  currp->state = CH_STATE_CURRENT;
     698:	81 e0       	ldi	r24, 0x01	; 1
     69a:	8d 87       	std	Y+13, r24	; 0x0d

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
     69c:	14 96       	adiw	r26, 0x04	; 4
     69e:	2c 91       	ld	r18, X
     6a0:	14 97       	sbiw	r26, 0x04	; 4
  tp->state = CH_STATE_READY;
     6a2:	1d 96       	adiw	r26, 0x0d	; 13
     6a4:	1c 92       	st	X, r1
     6a6:	1d 97       	sbiw	r26, 0x0d	; 13
  cp = (thread_t *)&ch.rlist.queue;
     6a8:	ea e2       	ldi	r30, 0x2A	; 42
     6aa:	f3 e0       	ldi	r31, 0x03	; 3
    cp = cp->queue.next;
     6ac:	01 90       	ld	r0, Z+
     6ae:	f0 81       	ld	r31, Z
     6b0:	e0 2d       	mov	r30, r0
  } while (cp->prio > tp->prio);
     6b2:	94 81       	ldd	r25, Z+4	; 0x04
     6b4:	29 17       	cp	r18, r25
     6b6:	d0 f3       	brcs	.-12     	; 0x6ac <chSchDoRescheduleAhead+0x46>
  tp->queue.next             = cp;
     6b8:	11 96       	adiw	r26, 0x01	; 1
     6ba:	fc 93       	st	X, r31
     6bc:	ee 93       	st	-X, r30
  tp->queue.prev             = cp->queue.prev;
     6be:	82 81       	ldd	r24, Z+2	; 0x02
     6c0:	93 81       	ldd	r25, Z+3	; 0x03
     6c2:	13 96       	adiw	r26, 0x03	; 3
     6c4:	9c 93       	st	X, r25
     6c6:	8e 93       	st	-X, r24
     6c8:	12 97       	sbiw	r26, 0x02	; 2
  tp->queue.prev->queue.next = tp;
     6ca:	ec 01       	movw	r28, r24
     6cc:	b9 83       	std	Y+1, r27	; 0x01
     6ce:	a8 83       	st	Y, r26
  cp->queue.prev             = tp;
     6d0:	b3 83       	std	Z+3, r27	; 0x03
     6d2:	a2 83       	std	Z+2, r26	; 0x02

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
     6d4:	bd 01       	movw	r22, r26
     6d6:	ca 01       	movw	r24, r20
     6d8:	e7 d1       	rcall	.+974    	; 0xaa8 <_port_switch>
}
     6da:	df 91       	pop	r29
     6dc:	cf 91       	pop	r28
     6de:	08 95       	ret

000006e0 <chSchDoReschedule>:
     6e0:	c2 cf       	rjmp	.-124    	; 0x666 <chSchDoRescheduleAhead>

000006e2 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
     6e2:	cf 93       	push	r28
     6e4:	df 93       	push	r29
     6e6:	fc 01       	movw	r30, r24

  tp->prio      = prio;
     6e8:	44 83       	std	Z+4, r20	; 0x04
  tp->state     = CH_STATE_WTSTART;
     6ea:	82 e0       	ldi	r24, 0x02	; 2
     6ec:	85 87       	std	Z+13, r24	; 0x0d
  tp->flags     = CH_FLAG_MODE_STATIC;
     6ee:	16 86       	std	Z+14, r1	; 0x0e
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
     6f0:	43 8f       	std	Z+27, r20	; 0x1b
  tp->mtxlist   = NULL;
     6f2:	12 8e       	std	Z+26, r1	; 0x1a
     6f4:	11 8e       	std	Z+25, r1	; 0x19
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
     6f6:	10 8e       	std	Z+24, r1	; 0x18
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
     6f8:	81 e0       	ldi	r24, 0x01	; 1
     6fa:	87 87       	std	Z+15, r24	; 0x0f
  tp->name      = name;
     6fc:	74 87       	std	Z+12, r23	; 0x0c
     6fe:	63 87       	std	Z+11, r22	; 0x0b
  REG_INSERT(tp);
     700:	aa e2       	ldi	r26, 0x2A	; 42
     702:	b3 e0       	ldi	r27, 0x03	; 3
     704:	b0 87       	std	Z+8, r27	; 0x08
     706:	a7 83       	std	Z+7, r26	; 0x07
     708:	19 96       	adiw	r26, 0x09	; 9
     70a:	cd 91       	ld	r28, X+
     70c:	dc 91       	ld	r29, X
     70e:	1a 97       	sbiw	r26, 0x0a	; 10
     710:	d2 87       	std	Z+10, r29	; 0x0a
     712:	c1 87       	std	Z+9, r28	; 0x09
     714:	f8 87       	std	Y+8, r31	; 0x08
     716:	ef 83       	std	Y+7, r30	; 0x07
     718:	1a 96       	adiw	r26, 0x0a	; 10
     71a:	fc 93       	st	X, r31
     71c:	ee 93       	st	-X, r30
     71e:	19 97       	sbiw	r26, 0x09	; 9
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
     720:	cf 01       	movw	r24, r30
     722:	42 96       	adiw	r24, 0x12	; 18
  tlp->next = (thread_t *)tlp;
     724:	93 8b       	std	Z+19, r25	; 0x13
     726:	82 8b       	std	Z+18, r24	; 0x12
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
     728:	02 96       	adiw	r24, 0x02	; 2
  tqp->next = (thread_t *)tqp;
     72a:	95 8b       	std	Z+21, r25	; 0x15
     72c:	84 8b       	std	Z+20, r24	; 0x14
  tqp->prev = (thread_t *)tqp;
     72e:	97 8b       	std	Z+23, r25	; 0x17
     730:	86 8b       	std	Z+22, r24	; 0x16
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
}
     732:	cf 01       	movw	r24, r30
     734:	df 91       	pop	r29
     736:	cf 91       	pop	r28
     738:	08 95       	ret

0000073a <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
     73a:	cf 93       	push	r28
     73c:	df 93       	push	r29
     73e:	dc 01       	movw	r26, r24
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
     740:	14 96       	adiw	r26, 0x04	; 4
     742:	2d 91       	ld	r18, X+
     744:	3c 91       	ld	r19, X
     746:	15 97       	sbiw	r26, 0x05	; 5
     748:	f9 01       	movw	r30, r18
     74a:	7c 97       	sbiw	r30, 0x1c	; 28
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
     74c:	e9 01       	movw	r28, r18
     74e:	e1 97       	sbiw	r28, 0x31	; 49
     750:	d6 83       	std	Z+6, r29	; 0x06
     752:	c5 83       	std	Z+5, r28	; 0x05
     754:	17 96       	adiw	r26, 0x07	; 7
     756:	9c 91       	ld	r25, X
     758:	17 97       	sbiw	r26, 0x07	; 7
     75a:	18 96       	adiw	r26, 0x08	; 8
     75c:	8c 91       	ld	r24, X
     75e:	18 97       	sbiw	r26, 0x08	; 8
     760:	9a 8b       	std	Y+18, r25	; 0x12
     762:	89 8b       	std	Y+17, r24	; 0x11
     764:	19 96       	adiw	r26, 0x09	; 9
     766:	9c 91       	ld	r25, X
     768:	19 97       	sbiw	r26, 0x09	; 9
     76a:	1a 96       	adiw	r26, 0x0a	; 10
     76c:	8c 91       	ld	r24, X
     76e:	1a 97       	sbiw	r26, 0x0a	; 10
     770:	98 8b       	std	Y+16, r25	; 0x10
     772:	8f 87       	std	Y+15, r24	; 0x0f
     774:	83 e8       	ldi	r24, 0x83	; 131
     776:	95 e0       	ldi	r25, 0x05	; 5
     778:	9b 8b       	std	Y+19, r25	; 0x13
     77a:	8c 8b       	std	Y+20, r24	; 0x14

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
     77c:	16 96       	adiw	r26, 0x06	; 6
     77e:	8c 91       	ld	r24, X
     780:	16 97       	sbiw	r26, 0x06	; 6
     782:	4d 91       	ld	r20, X+
     784:	5c 91       	ld	r21, X
  tp->prio      = prio;
     786:	84 83       	std	Z+4, r24	; 0x04
  tp->state     = CH_STATE_WTSTART;
     788:	92 e0       	ldi	r25, 0x02	; 2
     78a:	95 87       	std	Z+13, r25	; 0x0d
  tp->flags     = CH_FLAG_MODE_STATIC;
     78c:	16 86       	std	Z+14, r1	; 0x0e
  tp->realprio  = prio;
     78e:	83 8f       	std	Z+27, r24	; 0x1b
  tp->mtxlist   = NULL;
     790:	12 8e       	std	Z+26, r1	; 0x1a
     792:	11 8e       	std	Z+25, r1	; 0x19
  tp->epending  = (eventmask_t)0;
     794:	10 8e       	std	Z+24, r1	; 0x18
  tp->refs      = (trefs_t)1;
     796:	81 e0       	ldi	r24, 0x01	; 1
     798:	87 87       	std	Z+15, r24	; 0x0f
  tp->name      = name;
     79a:	54 87       	std	Z+12, r21	; 0x0c
     79c:	43 87       	std	Z+11, r20	; 0x0b
  REG_INSERT(tp);
     79e:	aa e2       	ldi	r26, 0x2A	; 42
     7a0:	b3 e0       	ldi	r27, 0x03	; 3
     7a2:	b0 87       	std	Z+8, r27	; 0x08
     7a4:	a7 83       	std	Z+7, r26	; 0x07
     7a6:	19 96       	adiw	r26, 0x09	; 9
     7a8:	cd 91       	ld	r28, X+
     7aa:	dc 91       	ld	r29, X
     7ac:	1a 97       	sbiw	r26, 0x0a	; 10
     7ae:	d2 87       	std	Z+10, r29	; 0x0a
     7b0:	c1 87       	std	Z+9, r28	; 0x09
     7b2:	f8 87       	std	Y+8, r31	; 0x08
     7b4:	ef 83       	std	Y+7, r30	; 0x07
     7b6:	1a 96       	adiw	r26, 0x0a	; 10
     7b8:	fc 93       	st	X, r31
     7ba:	ee 93       	st	-X, r30
     7bc:	19 97       	sbiw	r26, 0x09	; 9
  tlp->next = (thread_t *)tlp;
     7be:	d9 01       	movw	r26, r18
     7c0:	1a 97       	sbiw	r26, 0x0a	; 10
     7c2:	0b 2e       	mov	r0, r27
     7c4:	11 96       	adiw	r26, 0x01	; 1
     7c6:	0c 92       	st	X, r0
     7c8:	11 97       	sbiw	r26, 0x01	; 1
     7ca:	ac 93       	st	X, r26
  queue_init(&tp->msgqueue);
     7cc:	12 96       	adiw	r26, 0x02	; 2
  tqp->next = (thread_t *)tqp;
     7ce:	0b 2e       	mov	r0, r27
     7d0:	11 96       	adiw	r26, 0x01	; 1
     7d2:	0c 92       	st	X, r0
     7d4:	11 97       	sbiw	r26, 0x01	; 1
     7d6:	ac 93       	st	X, r26
  tqp->prev = (thread_t *)tqp;
     7d8:	0a 2e       	mov	r0, r26
     7da:	1b 2e       	mov	r1, r27
     7dc:	13 96       	adiw	r26, 0x03	; 3
     7de:	1c 92       	st	X, r1
     7e0:	0e 92       	st	-X, r0
     7e2:	11 24       	eor	r1, r1
     7e4:	12 97       	sbiw	r26, 0x02	; 2
}
     7e6:	cf 01       	movw	r24, r30
     7e8:	df 91       	pop	r29
     7ea:	cf 91       	pop	r28
     7ec:	08 95       	ret

000007ee <chThdCreate>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
     7ee:	cf 93       	push	r28
     7f0:	df 93       	push	r29
  asm volatile ("cli" : : : "memory");
     7f2:	f8 94       	cli
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
     7f4:	a2 df       	rcall	.-188    	; 0x73a <chThdCreateSuspendedI>
     7f6:	ec 01       	movw	r28, r24
  chSchWakeupS(tp, MSG_OK);
     7f8:	70 e0       	ldi	r23, 0x00	; 0
     7fa:	60 e0       	ldi	r22, 0x00	; 0
     7fc:	d4 de       	rcall	.-600    	; 0x5a6 <chSchWakeupS>
  asm volatile ("sei" : : : "memory");
     7fe:	78 94       	sei
  chSysUnlock();

  return tp;
}
     800:	ce 01       	movw	r24, r28
     802:	df 91       	pop	r29
     804:	cf 91       	pop	r28
     806:	08 95       	ret

00000808 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
     808:	0f 93       	push	r16
     80a:	1f 93       	push	r17
     80c:	cf 93       	push	r28
     80e:	df 93       	push	r29
  asm volatile ("cli" : : : "memory");
     810:	f8 94       	cli
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
     812:	6c 51       	subi	r22, 0x1C	; 28
     814:	71 09       	sbc	r23, r1
     816:	ec 01       	movw	r28, r24
     818:	c6 0f       	add	r28, r22
     81a:	d7 1f       	adc	r29, r23
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
     81c:	fe 01       	movw	r30, r28
     81e:	75 97       	sbiw	r30, 0x15	; 21
     820:	fe 83       	std	Y+6, r31	; 0x06
     822:	ed 83       	std	Y+5, r30	; 0x05
     824:	22 8b       	std	Z+18, r18	; 0x12
     826:	31 8b       	std	Z+17, r19	; 0x11
     828:	00 8b       	std	Z+16, r16	; 0x10
     82a:	17 87       	std	Z+15, r17	; 0x0f
     82c:	83 e8       	ldi	r24, 0x83	; 131
     82e:	95 e0       	ldi	r25, 0x05	; 5
     830:	93 8b       	std	Z+19, r25	; 0x13
     832:	84 8b       	std	Z+20, r24	; 0x14
  tp->prio      = prio;
     834:	4c 83       	std	Y+4, r20	; 0x04
  tp->state     = CH_STATE_WTSTART;
     836:	82 e0       	ldi	r24, 0x02	; 2
     838:	8d 87       	std	Y+13, r24	; 0x0d
  tp->flags     = CH_FLAG_MODE_STATIC;
     83a:	1e 86       	std	Y+14, r1	; 0x0e
  tp->realprio  = prio;
     83c:	4b 8f       	std	Y+27, r20	; 0x1b
  tp->mtxlist   = NULL;
     83e:	1a 8e       	std	Y+26, r1	; 0x1a
     840:	19 8e       	std	Y+25, r1	; 0x19
  tp->epending  = (eventmask_t)0;
     842:	18 8e       	std	Y+24, r1	; 0x18
  tp->refs      = (trefs_t)1;
     844:	81 e0       	ldi	r24, 0x01	; 1
     846:	8f 87       	std	Y+15, r24	; 0x0f
  tp->name      = name;
     848:	86 e1       	ldi	r24, 0x16	; 22
     84a:	91 e0       	ldi	r25, 0x01	; 1
     84c:	9c 87       	std	Y+12, r25	; 0x0c
     84e:	8b 87       	std	Y+11, r24	; 0x0b
  REG_INSERT(tp);
     850:	ea e2       	ldi	r30, 0x2A	; 42
     852:	f3 e0       	ldi	r31, 0x03	; 3
     854:	f8 87       	std	Y+8, r31	; 0x08
     856:	ef 83       	std	Y+7, r30	; 0x07
     858:	a1 85       	ldd	r26, Z+9	; 0x09
     85a:	b2 85       	ldd	r27, Z+10	; 0x0a
     85c:	ba 87       	std	Y+10, r27	; 0x0a
     85e:	a9 87       	std	Y+9, r26	; 0x09
     860:	18 96       	adiw	r26, 0x08	; 8
     862:	dc 93       	st	X, r29
     864:	ce 93       	st	-X, r28
     866:	17 97       	sbiw	r26, 0x07	; 7
     868:	d2 87       	std	Z+10, r29	; 0x0a
     86a:	c1 87       	std	Z+9, r28	; 0x09
  list_init(&tp->waiting);
     86c:	ce 01       	movw	r24, r28
     86e:	42 96       	adiw	r24, 0x12	; 18
  tlp->next = (thread_t *)tlp;
     870:	9b 8b       	std	Y+19, r25	; 0x13
     872:	8a 8b       	std	Y+18, r24	; 0x12
  queue_init(&tp->msgqueue);
     874:	02 96       	adiw	r24, 0x02	; 2
  tqp->next = (thread_t *)tqp;
     876:	9d 8b       	std	Y+21, r25	; 0x15
     878:	8c 8b       	std	Y+20, r24	; 0x14
  tqp->prev = (thread_t *)tqp;
     87a:	9f 8b       	std	Y+23, r25	; 0x17
     87c:	8e 8b       	std	Y+22, r24	; 0x16

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
     87e:	70 e0       	ldi	r23, 0x00	; 0
     880:	60 e0       	ldi	r22, 0x00	; 0
     882:	ce 01       	movw	r24, r28
     884:	90 de       	rcall	.-736    	; 0x5a6 <chSchWakeupS>
  asm volatile ("sei" : : : "memory");
     886:	78 94       	sei
  chSysUnlock();

  return tp;
}
     888:	ce 01       	movw	r24, r28
     88a:	df 91       	pop	r29
     88c:	cf 91       	pop	r28
     88e:	1f 91       	pop	r17
     890:	0f 91       	pop	r16
     892:	08 95       	ret

00000894 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
     894:	0f 93       	push	r16
     896:	1f 93       	push	r17
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
  thread_t *tp = currp;
     89c:	c0 91 35 03 	lds	r28, 0x0335	; 0x800335 <ch+0xb>
     8a0:	d0 91 36 03 	lds	r29, 0x0336	; 0x800336 <ch+0xc>

  /* Storing exit message.*/
  tp->u.exitcode = msg;
     8a4:	99 8b       	std	Y+17, r25	; 0x11
     8a6:	88 8b       	std	Y+16, r24	; 0x10
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
     8a8:	8e 01       	movw	r16, r28
     8aa:	0e 5e       	subi	r16, 0xEE	; 238
     8ac:	1f 4f       	sbci	r17, 0xFF	; 255
  return (bool)(tlp->next != (thread_t *)tlp);
     8ae:	8a 89       	ldd	r24, Y+18	; 0x12
     8b0:	9b 89       	ldd	r25, Y+19	; 0x13
     8b2:	08 17       	cp	r16, r24
     8b4:	19 07       	cpc	r17, r25
     8b6:	59 f0       	breq	.+22     	; 0x8ce <chThdExitS+0x3a>
  tlp->next = tp->queue.next;
     8b8:	fc 01       	movw	r30, r24
     8ba:	20 81       	ld	r18, Z
     8bc:	31 81       	ldd	r19, Z+1	; 0x01
     8be:	3b 8b       	std	Y+19, r19	; 0x13
     8c0:	2a 8b       	std	Y+18, r18	; 0x12
    (void) chSchReadyI(list_remove(&tp->waiting));
     8c2:	ff dd       	rcall	.-1026   	; 0x4c2 <chSchReadyI>
  return (bool)(tlp->next != (thread_t *)tlp);
     8c4:	8a 89       	ldd	r24, Y+18	; 0x12
     8c6:	9b 89       	ldd	r25, Y+19	; 0x13
  while (list_notempty(&tp->waiting)) {
     8c8:	80 17       	cp	r24, r16
     8ca:	91 07       	cpc	r25, r17
     8cc:	a9 f7       	brne	.-22     	; 0x8b8 <chThdExitS+0x24>
  if ((tp->refs == (trefs_t)0) &&
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
  }
#else
  if (tp->refs == (trefs_t)0) {
     8ce:	8f 85       	ldd	r24, Y+15	; 0x0f
     8d0:	81 11       	cpse	r24, r1
     8d2:	0a c0       	rjmp	.+20     	; 0x8e8 <chThdExitS+0x54>
    REG_REMOVE(tp);
     8d4:	a9 85       	ldd	r26, Y+9	; 0x09
     8d6:	ba 85       	ldd	r27, Y+10	; 0x0a
     8d8:	ef 81       	ldd	r30, Y+7	; 0x07
     8da:	f8 85       	ldd	r31, Y+8	; 0x08
     8dc:	18 96       	adiw	r26, 0x08	; 8
     8de:	fc 93       	st	X, r31
     8e0:	ee 93       	st	-X, r30
     8e2:	17 97       	sbiw	r26, 0x07	; 7
     8e4:	b2 87       	std	Z+10, r27	; 0x0a
     8e6:	a1 87       	std	Z+9, r26	; 0x09
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
     8e8:	8f e0       	ldi	r24, 0x0F	; 15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
     8ea:	df 91       	pop	r29
     8ec:	cf 91       	pop	r28
     8ee:	1f 91       	pop	r17
  chSchGoSleepS(CH_STATE_FINAL);
     8f0:	0f 91       	pop	r16
     8f2:	09 ce       	rjmp	.-1006   	; 0x506 <chSchGoSleepS>

000008f4 <chThdExit>:
  asm volatile ("cli" : : : "memory");
     8f4:	f8 94       	cli
  chThdExitS(msg);
     8f6:	ce cf       	rjmp	.-100    	; 0x894 <chThdExitS>

000008f8 <chThdSleep>:
     8f8:	f8 94       	cli
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
     8fa:	bc 01       	movw	r22, r24
     8fc:	88 e0       	ldi	r24, 0x08	; 8
     8fe:	1f de       	rcall	.-962    	; 0x53e <chSchGoSleepTimeoutS>
  asm volatile ("sei" : : : "memory");
     900:	78 94       	sei
void chThdSleep(sysinterval_t time) {

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
     902:	08 95       	ret

00000904 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
     904:	dc 01       	movw	r26, r24
     906:	ed 91       	ld	r30, X+
     908:	fc 91       	ld	r31, X
     90a:	11 97       	sbiw	r26, 0x01	; 1
     90c:	30 97       	sbiw	r30, 0x00	; 0
     90e:	31 f0       	breq	.+12     	; 0x91c <chThdResumeI+0x18>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
     910:	1d 92       	st	X+, r1
     912:	1c 92       	st	X, r1
    tp->u.rdymsg = msg;
     914:	71 8b       	std	Z+17, r23	; 0x11
     916:	60 8b       	std	Z+16, r22	; 0x10
    (void) chSchReadyI(tp);
     918:	cf 01       	movw	r24, r30
     91a:	d3 cd       	rjmp	.-1114   	; 0x4c2 <chSchReadyI>
  }
}
     91c:	08 95       	ret

0000091e <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
     91e:	cf 93       	push	r28
     920:	df 93       	push	r29

  if (TIME_IMMEDIATE == timeout) {
     922:	61 15       	cp	r22, r1
     924:	71 05       	cpc	r23, r1
     926:	99 f0       	breq	.+38     	; 0x94e <chThdEnqueueTimeoutS+0x30>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
     928:	e0 91 35 03 	lds	r30, 0x0335	; 0x800335 <ch+0xb>
     92c:	f0 91 36 03 	lds	r31, 0x0336	; 0x800336 <ch+0xc>
  tp->queue.next             = (thread_t *)tqp;
     930:	91 83       	std	Z+1, r25	; 0x01
     932:	80 83       	st	Z, r24
  tp->queue.prev             = tqp->prev;
     934:	ec 01       	movw	r28, r24
     936:	aa 81       	ldd	r26, Y+2	; 0x02
     938:	bb 81       	ldd	r27, Y+3	; 0x03
     93a:	b3 83       	std	Z+3, r27	; 0x03
     93c:	a2 83       	std	Z+2, r26	; 0x02
  tp->queue.prev->queue.next = tp;
     93e:	ed 93       	st	X+, r30
     940:	fc 93       	st	X, r31
  tqp->prev                  = tp;
     942:	fb 83       	std	Y+3, r31	; 0x03
     944:	ea 83       	std	Y+2, r30	; 0x02

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
     946:	84 e0       	ldi	r24, 0x04	; 4
}
     948:	df 91       	pop	r29
     94a:	cf 91       	pop	r28
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
     94c:	f8 cd       	rjmp	.-1040   	; 0x53e <chSchGoSleepTimeoutS>
}
     94e:	8f ef       	ldi	r24, 0xFF	; 255
     950:	9f ef       	ldi	r25, 0xFF	; 255
     952:	df 91       	pop	r29
     954:	cf 91       	pop	r28
     956:	08 95       	ret

00000958 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
     958:	cf 93       	push	r28
     95a:	df 93       	push	r29
     95c:	fc 01       	movw	r30, r24
  return (bool)(tqp->next != (const thread_t *)tqp);
     95e:	80 81       	ld	r24, Z
     960:	91 81       	ldd	r25, Z+1	; 0x01

  if (queue_notempty(tqp)) {
     962:	e8 17       	cp	r30, r24
     964:	f9 07       	cpc	r31, r25
     966:	71 f0       	breq	.+28     	; 0x984 <chThdDequeueNextI+0x2c>
  tqp->next             = tp->queue.next;
     968:	ec 01       	movw	r28, r24
     96a:	a8 81       	ld	r26, Y
     96c:	b9 81       	ldd	r27, Y+1	; 0x01
     96e:	b1 83       	std	Z+1, r27	; 0x01
     970:	a0 83       	st	Z, r26
  tqp->next->queue.prev = (thread_t *)tqp;
     972:	13 96       	adiw	r26, 0x03	; 3
     974:	fc 93       	st	X, r31
     976:	ee 93       	st	-X, r30
     978:	12 97       	sbiw	r26, 0x02	; 2

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
     97a:	79 8b       	std	Y+17, r23	; 0x11
     97c:	68 8b       	std	Y+16, r22	; 0x10
    chThdDoDequeueNextI(tqp, msg);
  }
}
     97e:	df 91       	pop	r29
     980:	cf 91       	pop	r28
  (void) chSchReadyI(tp);
     982:	9f cd       	rjmp	.-1218   	; 0x4c2 <chSchReadyI>
     984:	df 91       	pop	r29
     986:	cf 91       	pop	r28
     988:	08 95       	ret

0000098a <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
     98a:	fc 01       	movw	r30, r24
  tqp->next = (thread_t *)tqp;
     98c:	91 83       	std	Z+1, r25	; 0x01
     98e:	80 83       	st	Z, r24
  tqp->prev = (thread_t *)tqp;
     990:	93 83       	std	Z+3, r25	; 0x03
     992:	82 83       	std	Z+2, r24	; 0x02

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
     994:	15 82       	std	Z+5, r1	; 0x05
     996:	14 82       	std	Z+4, r1	; 0x04
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
     998:	08 95       	ret

0000099a <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
     99a:	fc 01       	movw	r30, r24

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
     99c:	80 8d       	ldd	r24, Z+24	; 0x18
     99e:	68 2b       	or	r22, r24
     9a0:	60 8f       	std	Z+24, r22	; 0x18
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
     9a2:	85 85       	ldd	r24, Z+13	; 0x0d
     9a4:	8a 30       	cpi	r24, 0x0A	; 10
     9a6:	59 f0       	breq	.+22     	; 0x9be <chEvtSignalI+0x24>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
     9a8:	8b 30       	cpi	r24, 0x0B	; 11
     9aa:	09 f0       	breq	.+2      	; 0x9ae <chEvtSignalI+0x14>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
     9ac:	08 95       	ret
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
     9ae:	80 89       	ldd	r24, Z+16	; 0x10
     9b0:	68 23       	and	r22, r24
      ((tp->state == CH_STATE_WTANDEVT) &&
     9b2:	86 13       	cpse	r24, r22
     9b4:	fb cf       	rjmp	.-10     	; 0x9ac <chEvtSignalI+0x12>
    tp->u.rdymsg = MSG_OK;
     9b6:	11 8a       	std	Z+17, r1	; 0x11
     9b8:	10 8a       	std	Z+16, r1	; 0x10
    (void) chSchReadyI(tp);
     9ba:	cf 01       	movw	r24, r30
     9bc:	82 cd       	rjmp	.-1276   	; 0x4c2 <chSchReadyI>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
     9be:	80 89       	ldd	r24, Z+16	; 0x10
     9c0:	68 23       	and	r22, r24
  if (((tp->state == CH_STATE_WTOREVT) &&
     9c2:	c9 f7       	brne	.-14     	; 0x9b6 <chEvtSignalI+0x1c>
     9c4:	08 95       	ret

000009c6 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
     9c6:	ef 92       	push	r14
     9c8:	ff 92       	push	r15
     9ca:	1f 93       	push	r17
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
     9d0:	7c 01       	movw	r14, r24
     9d2:	16 2f       	mov	r17, r22
  elp = esp->next;
     9d4:	fc 01       	movw	r30, r24
     9d6:	c0 81       	ld	r28, Z
     9d8:	d1 81       	ldd	r29, Z+1	; 0x01
  while (elp != (event_listener_t *)esp) {
     9da:	8c 17       	cp	r24, r28
     9dc:	9d 07       	cpc	r25, r29
     9de:	91 f0       	breq	.+36     	; 0xa04 <chEvtBroadcastFlagsI+0x3e>
    elp->flags |= flags;
     9e0:	8d 81       	ldd	r24, Y+5	; 0x05
     9e2:	81 2b       	or	r24, r17
     9e4:	8d 83       	std	Y+5, r24	; 0x05
    if ((flags == (eventflags_t)0) ||
     9e6:	11 23       	and	r17, r17
     9e8:	19 f0       	breq	.+6      	; 0x9f0 <chEvtBroadcastFlagsI+0x2a>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
     9ea:	9e 81       	ldd	r25, Y+6	; 0x06
     9ec:	89 23       	and	r24, r25
    if ((flags == (eventflags_t)0) ||
     9ee:	21 f0       	breq	.+8      	; 0x9f8 <chEvtBroadcastFlagsI+0x32>
      chEvtSignalI(elp->listener, elp->events);
     9f0:	6c 81       	ldd	r22, Y+4	; 0x04
     9f2:	8a 81       	ldd	r24, Y+2	; 0x02
     9f4:	9b 81       	ldd	r25, Y+3	; 0x03
     9f6:	d1 df       	rcall	.-94     	; 0x99a <chEvtSignalI>
    elp = elp->next;
     9f8:	09 90       	ld	r0, Y+
     9fa:	d8 81       	ld	r29, Y
     9fc:	c0 2d       	mov	r28, r0
  while (elp != (event_listener_t *)esp) {
     9fe:	ec 16       	cp	r14, r28
     a00:	fd 06       	cpc	r15, r29
     a02:	71 f7       	brne	.-36     	; 0x9e0 <chEvtBroadcastFlagsI+0x1a>
}
     a04:	df 91       	pop	r29
     a06:	cf 91       	pop	r28
     a08:	1f 91       	pop	r17
     a0a:	ff 90       	pop	r15
     a0c:	ef 90       	pop	r14
     a0e:	08 95       	ret

00000a10 <_core_init>:
  ch_memcore.endmem  = __heap_end__;
  /*lint restore*/
#else
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.nextmem = &static_heap[0];
     a10:	ed e5       	ldi	r30, 0x5D	; 93
     a12:	f3 e0       	ldi	r31, 0x03	; 3
     a14:	82 eb       	ldi	r24, 0xB2	; 178
     a16:	91 e0       	ldi	r25, 0x01	; 1
     a18:	91 83       	std	Z+1, r25	; 0x01
     a1a:	80 83       	st	Z, r24
  ch_memcore.endmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
     a1c:	82 e3       	ldi	r24, 0x32	; 50
     a1e:	92 e0       	ldi	r25, 0x02	; 2
     a20:	93 83       	std	Z+3, r25	; 0x03
     a22:	82 83       	std	Z+2, r24	; 0x02
#endif
}
     a24:	08 95       	ret

00000a26 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
     a26:	cf 93       	push	r28
     a28:	df 93       	push	r29
     a2a:	9c 01       	movw	r18, r24
  asm volatile ("cli" : : : "memory");
     a2c:	f8 94       	cli
  size = MEM_ALIGN_NEXT(size, align);
     a2e:	eb 01       	movw	r28, r22
     a30:	21 97       	sbiw	r28, 0x01	; 1
     a32:	ee 27       	eor	r30, r30
     a34:	ff 27       	eor	r31, r31
     a36:	e6 1b       	sub	r30, r22
     a38:	f7 0b       	sbc	r31, r23
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
     a3a:	a0 91 5d 03 	lds	r26, 0x035D	; 0x80035d <ch_memcore>
     a3e:	b0 91 5e 03 	lds	r27, 0x035E	; 0x80035e <ch_memcore+0x1>
     a42:	cd 01       	movw	r24, r26
     a44:	84 0f       	add	r24, r20
     a46:	95 1f       	adc	r25, r21
     a48:	8c 0f       	add	r24, r28
     a4a:	9d 1f       	adc	r25, r29
     a4c:	8e 23       	and	r24, r30
     a4e:	9f 23       	and	r25, r31
  size = MEM_ALIGN_NEXT(size, align);
     a50:	b9 01       	movw	r22, r18
     a52:	6c 0f       	add	r22, r28
     a54:	7d 1f       	adc	r23, r29
     a56:	6e 23       	and	r22, r30
     a58:	7f 23       	and	r23, r31
  next = p + size;
     a5a:	68 0f       	add	r22, r24
     a5c:	79 1f       	adc	r23, r25
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
     a5e:	20 91 5f 03 	lds	r18, 0x035F	; 0x80035f <ch_memcore+0x2>
     a62:	30 91 60 03 	lds	r19, 0x0360	; 0x800360 <ch_memcore+0x3>
     a66:	26 17       	cp	r18, r22
     a68:	37 07       	cpc	r19, r23
     a6a:	58 f0       	brcs	.+22     	; 0xa82 <chCoreAllocAlignedWithOffset+0x5c>
     a6c:	6a 17       	cp	r22, r26
     a6e:	7b 07       	cpc	r23, r27
     a70:	40 f0       	brcs	.+16     	; 0xa82 <chCoreAllocAlignedWithOffset+0x5c>
  ch_memcore.nextmem = next;
     a72:	70 93 5e 03 	sts	0x035E, r23	; 0x80035e <ch_memcore+0x1>
     a76:	60 93 5d 03 	sts	0x035D, r22	; 0x80035d <ch_memcore>
  asm volatile ("sei" : : : "memory");
     a7a:	78 94       	sei
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	08 95       	ret
    return NULL;
     a82:	90 e0       	ldi	r25, 0x00	; 0
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	78 94       	sei
}
     a88:	df 91       	pop	r29
     a8a:	cf 91       	pop	r28
     a8c:	08 95       	ret

00000a8e <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
     a8e:	e2 e3       	ldi	r30, 0x32	; 50
     a90:	f2 e0       	ldi	r31, 0x02	; 2
     a92:	83 e1       	ldi	r24, 0x13	; 19
     a94:	95 e0       	ldi	r25, 0x05	; 5
     a96:	91 83       	std	Z+1, r25	; 0x01
     a98:	80 83       	st	Z, r24
  H_NEXT(&default_heap.header) = NULL;
     a9a:	13 82       	std	Z+3, r1	; 0x03
     a9c:	12 82       	std	Z+2, r1	; 0x02
  H_PAGES(&default_heap.header) = 0;
     a9e:	15 82       	std	Z+5, r1	; 0x05
     aa0:	14 82       	std	Z+4, r1	; 0x04
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
     aa2:	88 e3       	ldi	r24, 0x38	; 56
     aa4:	92 e0       	ldi	r25, 0x02	; 2
     aa6:	71 cf       	rjmp	.-286    	; 0x98a <chMtxObjectInit>

00000aa8 <_port_switch>:
void _port_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;
  (void)otp;

  asm volatile ("push    r2");
     aa8:	2f 92       	push	r2
  asm volatile ("push    r3");
     aaa:	3f 92       	push	r3
  asm volatile ("push    r4");
     aac:	4f 92       	push	r4
  asm volatile ("push    r5");
     aae:	5f 92       	push	r5
  asm volatile ("push    r6");
     ab0:	6f 92       	push	r6
  asm volatile ("push    r7");
     ab2:	7f 92       	push	r7
  asm volatile ("push    r8");
     ab4:	8f 92       	push	r8
  asm volatile ("push    r9");
     ab6:	9f 92       	push	r9
  asm volatile ("push    r10");
     ab8:	af 92       	push	r10
  asm volatile ("push    r11");
     aba:	bf 92       	push	r11
  asm volatile ("push    r12");
     abc:	cf 92       	push	r12
  asm volatile ("push    r13");
     abe:	df 92       	push	r13
  asm volatile ("push    r14");
     ac0:	ef 92       	push	r14
  asm volatile ("push    r15");
     ac2:	ff 92       	push	r15
  asm volatile ("push    r16");
     ac4:	0f 93       	push	r16
  asm volatile ("push    r17");
     ac6:	1f 93       	push	r17
  asm volatile ("push    r28");
     ac8:	cf 93       	push	r28
  asm volatile ("push    r29");
     aca:	df 93       	push	r29

#if defined(_CHIBIOS_RT_)
  asm volatile ("movw    r30, r22");
     acc:	fb 01       	movw	r30, r22
  asm volatile ("in      r0, 0x3d");
     ace:	0d b6       	in	r0, 0x3d	; 61
  asm volatile ("std     Z+5, r0");
     ad0:	05 82       	std	Z+5, r0	; 0x05
  asm volatile ("in      r0, 0x3e");
     ad2:	0e b6       	in	r0, 0x3e	; 62
  asm volatile ("std     Z+6, r0");
     ad4:	06 82       	std	Z+6, r0	; 0x06

  asm volatile ("movw    r30, r24");
     ad6:	fc 01       	movw	r30, r24
  asm volatile ("ldd     r0, Z+5");
     ad8:	05 80       	ldd	r0, Z+5	; 0x05
  asm volatile ("out     0x3d, r0");
     ada:	0d be       	out	0x3d, r0	; 61
  asm volatile ("ldd     r0, Z+6");
     adc:	06 80       	ldd	r0, Z+6	; 0x06
  asm volatile ("out     0x3e, r0");
     ade:	0e be       	out	0x3e, r0	; 62
  asm volatile ("out     0x3d, r0");
  asm volatile ("ldd     r0, Z+1");
  asm volatile ("out     0x3e, r0");
#endif

  asm volatile ("pop     r29");
     ae0:	df 91       	pop	r29
  asm volatile ("pop     r28");
     ae2:	cf 91       	pop	r28
  asm volatile ("pop     r17");
     ae4:	1f 91       	pop	r17
  asm volatile ("pop     r16");
     ae6:	0f 91       	pop	r16
  asm volatile ("pop     r15");
     ae8:	ff 90       	pop	r15
  asm volatile ("pop     r14");
     aea:	ef 90       	pop	r14
  asm volatile ("pop     r13");
     aec:	df 90       	pop	r13
  asm volatile ("pop     r12");
     aee:	cf 90       	pop	r12
  asm volatile ("pop     r11");
     af0:	bf 90       	pop	r11
  asm volatile ("pop     r10");
     af2:	af 90       	pop	r10
  asm volatile ("pop     r9");
     af4:	9f 90       	pop	r9
  asm volatile ("pop     r8");
     af6:	8f 90       	pop	r8
  asm volatile ("pop     r7");
     af8:	7f 90       	pop	r7
  asm volatile ("pop     r6");
     afa:	6f 90       	pop	r6
  asm volatile ("pop     r5");
     afc:	5f 90       	pop	r5
  asm volatile ("pop     r4");
     afe:	4f 90       	pop	r4
  asm volatile ("pop     r3");
     b00:	3f 90       	pop	r3
  asm volatile ("pop     r2");
     b02:	2f 90       	pop	r2
  asm volatile ("ret");
     b04:	08 95       	ret

00000b06 <_port_thread_start>:
     b06:	78 94       	sei
 *          invoked.
 */
void _port_thread_start(void) {

  chSysUnlock();
  asm volatile ("movw    r24, r4");
     b08:	c2 01       	movw	r24, r4
  asm volatile ("movw    r30, r2");
     b0a:	f1 01       	movw	r30, r2
  asm volatile ("icall");
     b0c:	09 95       	icall
#if defined(_CHIBIOS_RT_)
  asm volatile ("call    chThdExit");  /* Used for avr5 Architecture. */
     b0e:	f2 ce       	rjmp	.-540    	; 0x8f4 <chThdExit>
#endif
#if defined(_CHIBIOS_NIL_)
  asm volatile ("call    chSysHalt");  /* Used for avr5 Architecture. */
#endif
}
     b10:	08 95       	ret

00000b12 <halInit>:

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
     b12:	1e d3       	rcall	.+1596   	; 0x1150 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
#else
  palInit(&pal_default_config);
     b14:	87 e4       	ldi	r24, 0x47	; 71
     b16:	91 e0       	ldi	r25, 0x01	; 1
#endif
#endif
#if (HAL_USE_ADC == TRUE) || defined(__DOXYGEN__)
  adcInit();
     b18:	81 d4       	rcall	.+2306   	; 0x141c <_pal_lld_init>
#endif
#if (HAL_USE_QSPI == TRUE) || defined(__DOXYGEN__)
  qspiInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
     b1a:	5f d2       	rcall	.+1214   	; 0xfda <adcInit>
     b1c:	a4 d2       	rcall	.+1352   	; 0x1066 <sdInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
     b1e:	c0 d5       	rcall	.+2944   	; 0x16a0 <boardInit>
     b20:	00 c0       	rjmp	.+0      	; 0xb22 <stInit>

00000b22 <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
     b22:	dd c4       	rjmp	.+2490   	; 0x14de <st_lld_init>

00000b24 <stStartAlarm>:
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  OCR1A = (uint16_t) time;
     b24:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     b28:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>

  /* Reset pending. */
  TIFR_REG = _BV(OCF1A);
     b2c:	82 e0       	ldi	r24, 0x02	; 2
     b2e:	86 bb       	out	0x16, r24	; 22

  /* Enable interrupt. */
  TIMSK_REG = _BV(OCIE1A);
     b30:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
}
     b34:	08 95       	ret

00000b36 <stStopAlarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  TIMSK_REG = 0;
     b36:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
     b3a:	08 95       	ret

00000b3c <stSetAlarm>:
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  OCR1A = (uint16_t) time;
     b3c:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     b40:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
     b44:	08 95       	ret

00000b46 <iq_read>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
     b46:	af 92       	push	r10
     b48:	bf 92       	push	r11
     b4a:	cf 92       	push	r12
     b4c:	df 92       	push	r13
     b4e:	ef 92       	push	r14
     b50:	ff 92       	push	r15
     b52:	0f 93       	push	r16
     b54:	1f 93       	push	r17
     b56:	cf 93       	push	r28
     b58:	df 93       	push	r29
     b5a:	ec 01       	movw	r28, r24
     b5c:	6b 01       	movw	r12, r22
     b5e:	8a 01       	movw	r16, r20
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
     b60:	8c 81       	ldd	r24, Y+4	; 0x04
     b62:	9d 81       	ldd	r25, Y+5	; 0x05
     b64:	84 17       	cp	r24, r20
     b66:	95 07       	cpc	r25, r21
     b68:	10 f4       	brcc	.+4      	; 0xb6e <iq_read+0x28>
    n = iqGetFullI(iqp);
     b6a:	0c 81       	ldd	r16, Y+4	; 0x04
     b6c:	1d 81       	ldd	r17, Y+5	; 0x05
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
     b6e:	6c 85       	ldd	r22, Y+12	; 0x0c
     b70:	7d 85       	ldd	r23, Y+13	; 0x0d
     b72:	e8 84       	ldd	r14, Y+8	; 0x08
     b74:	f9 84       	ldd	r15, Y+9	; 0x09
     b76:	e6 1a       	sub	r14, r22
     b78:	f7 0a       	sbc	r15, r23
  /*lint -restore*/
  if (n < s1) {
     b7a:	0e 15       	cp	r16, r14
     b7c:	1f 05       	cpc	r17, r15
     b7e:	98 f1       	brcs	.+102    	; 0xbe6 <iq_read+0xa0>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
    iqp->q_rdptr += n;
  }
  else if (n > s1) {
     b80:	e0 16       	cp	r14, r16
     b82:	f1 06       	cpc	r15, r17
     b84:	d0 f0       	brcs	.+52     	; 0xbba <iq_read+0x74>
    s2 = n - s1;
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
    iqp->q_rdptr = iqp->q_buffer + s2;
  }
  else { /* n == s1 */
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
     b86:	a8 01       	movw	r20, r16
     b88:	c6 01       	movw	r24, r12
     b8a:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
     b8e:	8e 81       	ldd	r24, Y+6	; 0x06
     b90:	9f 81       	ldd	r25, Y+7	; 0x07
     b92:	9d 87       	std	Y+13, r25	; 0x0d
     b94:	8c 87       	std	Y+12, r24	; 0x0c
  }

  iqp->q_counter -= n;
     b96:	8c 81       	ldd	r24, Y+4	; 0x04
     b98:	9d 81       	ldd	r25, Y+5	; 0x05
     b9a:	80 1b       	sub	r24, r16
     b9c:	91 0b       	sbc	r25, r17
     b9e:	9d 83       	std	Y+5, r25	; 0x05
     ba0:	8c 83       	std	Y+4, r24	; 0x04
  return n;
}
     ba2:	c8 01       	movw	r24, r16
     ba4:	df 91       	pop	r29
     ba6:	cf 91       	pop	r28
     ba8:	1f 91       	pop	r17
     baa:	0f 91       	pop	r16
     bac:	ff 90       	pop	r15
     bae:	ef 90       	pop	r14
     bb0:	df 90       	pop	r13
     bb2:	cf 90       	pop	r12
     bb4:	bf 90       	pop	r11
     bb6:	af 90       	pop	r10
     bb8:	08 95       	ret
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
     bba:	a7 01       	movw	r20, r14
     bbc:	c6 01       	movw	r24, r12
     bbe:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
    s2 = n - s1;
     bc2:	58 01       	movw	r10, r16
     bc4:	ae 18       	sub	r10, r14
     bc6:	bf 08       	sbc	r11, r15
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
     bc8:	6e 81       	ldd	r22, Y+6	; 0x06
     bca:	7f 81       	ldd	r23, Y+7	; 0x07
     bcc:	a5 01       	movw	r20, r10
     bce:	c6 01       	movw	r24, r12
     bd0:	8e 0d       	add	r24, r14
     bd2:	9f 1d       	adc	r25, r15
     bd4:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
     bd8:	4e 81       	ldd	r20, Y+6	; 0x06
     bda:	5f 81       	ldd	r21, Y+7	; 0x07
     bdc:	4a 0d       	add	r20, r10
     bde:	5b 1d       	adc	r21, r11
     be0:	5d 87       	std	Y+13, r21	; 0x0d
     be2:	4c 87       	std	Y+12, r20	; 0x0c
     be4:	d8 cf       	rjmp	.-80     	; 0xb96 <iq_read+0x50>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
     be6:	a8 01       	movw	r20, r16
     be8:	c6 01       	movw	r24, r12
     bea:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
    iqp->q_rdptr += n;
     bee:	8c 85       	ldd	r24, Y+12	; 0x0c
     bf0:	9d 85       	ldd	r25, Y+13	; 0x0d
     bf2:	80 0f       	add	r24, r16
     bf4:	91 1f       	adc	r25, r17
     bf6:	9d 87       	std	Y+13, r25	; 0x0d
     bf8:	8c 87       	std	Y+12, r24	; 0x0c
     bfa:	cd cf       	rjmp	.-102    	; 0xb96 <iq_read+0x50>

00000bfc <oq_write>:
 *                      value 0 is reserved
 * @return              The number of bytes effectively transferred.
 *
 * @notapi
 */
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
     bfc:	af 92       	push	r10
     bfe:	bf 92       	push	r11
     c00:	cf 92       	push	r12
     c02:	df 92       	push	r13
     c04:	ef 92       	push	r14
     c06:	ff 92       	push	r15
     c08:	0f 93       	push	r16
     c0a:	1f 93       	push	r17
     c0c:	cf 93       	push	r28
     c0e:	df 93       	push	r29
     c10:	ec 01       	movw	r28, r24
     c12:	6b 01       	movw	r12, r22
     c14:	8a 01       	movw	r16, r20
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
     c16:	8c 81       	ldd	r24, Y+4	; 0x04
     c18:	9d 81       	ldd	r25, Y+5	; 0x05
     c1a:	84 17       	cp	r24, r20
     c1c:	95 07       	cpc	r25, r21
     c1e:	10 f4       	brcc	.+4      	; 0xc24 <oq_write+0x28>
    n = oqGetEmptyI(oqp);
     c20:	0c 81       	ldd	r16, Y+4	; 0x04
     c22:	1d 81       	ldd	r17, Y+5	; 0x05
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
     c24:	8a 85       	ldd	r24, Y+10	; 0x0a
     c26:	9b 85       	ldd	r25, Y+11	; 0x0b
     c28:	e8 84       	ldd	r14, Y+8	; 0x08
     c2a:	f9 84       	ldd	r15, Y+9	; 0x09
     c2c:	e8 1a       	sub	r14, r24
     c2e:	f9 0a       	sbc	r15, r25
  /*lint -restore*/
  if (n < s1) {
     c30:	0e 15       	cp	r16, r14
     c32:	1f 05       	cpc	r17, r15
     c34:	98 f1       	brcs	.+102    	; 0xc9c <oq_write+0xa0>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
    oqp->q_wrptr += n;
  }
  else if (n > s1) {
     c36:	e0 16       	cp	r14, r16
     c38:	f1 06       	cpc	r15, r17
     c3a:	d0 f0       	brcs	.+52     	; 0xc70 <oq_write+0x74>
    s2 = n - s1;
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
    oqp->q_wrptr = oqp->q_buffer + s2;
  }
  else { /* n == s1 */
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
     c3c:	a8 01       	movw	r20, r16
     c3e:	b6 01       	movw	r22, r12
     c40:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
     c44:	8e 81       	ldd	r24, Y+6	; 0x06
     c46:	9f 81       	ldd	r25, Y+7	; 0x07
     c48:	9b 87       	std	Y+11, r25	; 0x0b
     c4a:	8a 87       	std	Y+10, r24	; 0x0a
  }

  oqp->q_counter -= n;
     c4c:	8c 81       	ldd	r24, Y+4	; 0x04
     c4e:	9d 81       	ldd	r25, Y+5	; 0x05
     c50:	80 1b       	sub	r24, r16
     c52:	91 0b       	sbc	r25, r17
     c54:	9d 83       	std	Y+5, r25	; 0x05
     c56:	8c 83       	std	Y+4, r24	; 0x04
  return n;
}
     c58:	c8 01       	movw	r24, r16
     c5a:	df 91       	pop	r29
     c5c:	cf 91       	pop	r28
     c5e:	1f 91       	pop	r17
     c60:	0f 91       	pop	r16
     c62:	ff 90       	pop	r15
     c64:	ef 90       	pop	r14
     c66:	df 90       	pop	r13
     c68:	cf 90       	pop	r12
     c6a:	bf 90       	pop	r11
     c6c:	af 90       	pop	r10
     c6e:	08 95       	ret
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
     c70:	a7 01       	movw	r20, r14
     c72:	b6 01       	movw	r22, r12
     c74:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
    s2 = n - s1;
     c78:	58 01       	movw	r10, r16
     c7a:	ae 18       	sub	r10, r14
     c7c:	bf 08       	sbc	r11, r15
    bp += s1;
     c7e:	b6 01       	movw	r22, r12
     c80:	6e 0d       	add	r22, r14
     c82:	7f 1d       	adc	r23, r15
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
     c84:	a5 01       	movw	r20, r10
     c86:	8e 81       	ldd	r24, Y+6	; 0x06
     c88:	9f 81       	ldd	r25, Y+7	; 0x07
     c8a:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
     c8e:	4e 81       	ldd	r20, Y+6	; 0x06
     c90:	5f 81       	ldd	r21, Y+7	; 0x07
     c92:	4a 0d       	add	r20, r10
     c94:	5b 1d       	adc	r21, r11
     c96:	5b 87       	std	Y+11, r21	; 0x0b
     c98:	4a 87       	std	Y+10, r20	; 0x0a
     c9a:	d8 cf       	rjmp	.-80     	; 0xc4c <oq_write+0x50>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
     c9c:	a8 01       	movw	r20, r16
     c9e:	b6 01       	movw	r22, r12
     ca0:	0e 94 ff 0e 	call	0x1dfe	; 0x1dfe <memcpy>
    oqp->q_wrptr += n;
     ca4:	8a 85       	ldd	r24, Y+10	; 0x0a
     ca6:	9b 85       	ldd	r25, Y+11	; 0x0b
     ca8:	80 0f       	add	r24, r16
     caa:	91 1f       	adc	r25, r17
     cac:	9b 87       	std	Y+11, r25	; 0x0b
     cae:	8a 87       	std	Y+10, r24	; 0x0a
     cb0:	cd cf       	rjmp	.-102    	; 0xc4c <oq_write+0x50>

00000cb2 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
     cb2:	0f 93       	push	r16
     cb4:	1f 93       	push	r17
     cb6:	fc 01       	movw	r30, r24
  tqp->next = (thread_t *)tqp;
     cb8:	91 83       	std	Z+1, r25	; 0x01
     cba:	80 83       	st	Z, r24
  tqp->prev = (thread_t *)tqp;
     cbc:	93 83       	std	Z+3, r25	; 0x03
     cbe:	82 83       	std	Z+2, r24	; 0x02

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
     cc0:	15 82       	std	Z+5, r1	; 0x05
     cc2:	14 82       	std	Z+4, r1	; 0x04
  iqp->q_buffer  = bp;
     cc4:	77 83       	std	Z+7, r23	; 0x07
     cc6:	66 83       	std	Z+6, r22	; 0x06
  iqp->q_rdptr   = bp;
     cc8:	75 87       	std	Z+13, r23	; 0x0d
     cca:	64 87       	std	Z+12, r22	; 0x0c
  iqp->q_wrptr   = bp;
     ccc:	73 87       	std	Z+11, r23	; 0x0b
     cce:	62 87       	std	Z+10, r22	; 0x0a
  iqp->q_top     = bp + size;
     cd0:	64 0f       	add	r22, r20
     cd2:	75 1f       	adc	r23, r21
     cd4:	71 87       	std	Z+9, r23	; 0x09
     cd6:	60 87       	std	Z+8, r22	; 0x08
  iqp->q_notify  = infy;
     cd8:	37 87       	std	Z+15, r19	; 0x0f
     cda:	26 87       	std	Z+14, r18	; 0x0e
  iqp->q_link    = link;
     cdc:	11 8b       	std	Z+17, r17	; 0x11
     cde:	00 8b       	std	Z+16, r16	; 0x10
}
     ce0:	1f 91       	pop	r17
     ce2:	0f 91       	pop	r16
     ce4:	08 95       	ret

00000ce6 <iqPutI>:
 * @retval MSG_OK       if the operation has been completed with success.
 * @retval MSG_TIMEOUT  if the queue is full.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
     ce6:	fc 01       	movw	r30, r24

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
     ce8:	a2 85       	ldd	r26, Z+10	; 0x0a
     cea:	b3 85       	ldd	r27, Z+11	; 0x0b
     cec:	84 85       	ldd	r24, Z+12	; 0x0c
     cee:	95 85       	ldd	r25, Z+13	; 0x0d
     cf0:	a8 17       	cp	r26, r24
     cf2:	b9 07       	cpc	r27, r25
     cf4:	e1 f0       	breq	.+56     	; 0xd2e <iqPutI+0x48>
    iqp->q_counter++;
     cf6:	84 81       	ldd	r24, Z+4	; 0x04
     cf8:	95 81       	ldd	r25, Z+5	; 0x05
     cfa:	01 96       	adiw	r24, 0x01	; 1
     cfc:	95 83       	std	Z+5, r25	; 0x05
     cfe:	84 83       	std	Z+4, r24	; 0x04
    *iqp->q_wrptr++ = b;
     d00:	cd 01       	movw	r24, r26
     d02:	01 96       	adiw	r24, 0x01	; 1
     d04:	93 87       	std	Z+11, r25	; 0x0b
     d06:	82 87       	std	Z+10, r24	; 0x0a
     d08:	6c 93       	st	X, r22
    if (iqp->q_wrptr >= iqp->q_top) {
     d0a:	22 85       	ldd	r18, Z+10	; 0x0a
     d0c:	33 85       	ldd	r19, Z+11	; 0x0b
     d0e:	80 85       	ldd	r24, Z+8	; 0x08
     d10:	91 85       	ldd	r25, Z+9	; 0x09
     d12:	28 17       	cp	r18, r24
     d14:	39 07       	cpc	r19, r25
     d16:	20 f0       	brcs	.+8      	; 0xd20 <iqPutI+0x3a>
      iqp->q_wrptr = iqp->q_buffer;
     d18:	86 81       	ldd	r24, Z+6	; 0x06
     d1a:	97 81       	ldd	r25, Z+7	; 0x07
     d1c:	93 87       	std	Z+11, r25	; 0x0b
     d1e:	82 87       	std	Z+10, r24	; 0x0a
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
     d20:	70 e0       	ldi	r23, 0x00	; 0
     d22:	60 e0       	ldi	r22, 0x00	; 0
     d24:	cf 01       	movw	r24, r30
     d26:	18 de       	rcall	.-976    	; 0x958 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);

    return MSG_OK;
     d28:	90 e0       	ldi	r25, 0x00	; 0
     d2a:	80 e0       	ldi	r24, 0x00	; 0
     d2c:	08 95       	ret
  if (!iqIsFullI(iqp)) {
     d2e:	84 81       	ldd	r24, Z+4	; 0x04
     d30:	95 81       	ldd	r25, Z+5	; 0x05
     d32:	89 2b       	or	r24, r25
     d34:	01 f3       	breq	.-64     	; 0xcf6 <iqPutI+0x10>
  }

  return MSG_TIMEOUT;
     d36:	8f ef       	ldi	r24, 0xFF	; 255
     d38:	9f ef       	ldi	r25, 0xFF	; 255
}
     d3a:	08 95       	ret

00000d3c <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
     d3c:	0f 93       	push	r16
     d3e:	1f 93       	push	r17
     d40:	cf 93       	push	r28
     d42:	df 93       	push	r29
     d44:	ec 01       	movw	r28, r24
     d46:	8b 01       	movw	r16, r22
  asm volatile ("cli" : : : "memory");
     d48:	f8 94       	cli
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
     d4a:	05 c0       	rjmp	.+10     	; 0xd56 <iqGetTimeout+0x1a>
  return chThdEnqueueTimeoutS(tqp, timeout);
     d4c:	b8 01       	movw	r22, r16
     d4e:	ce 01       	movw	r24, r28
     d50:	e6 dd       	rcall	.-1076   	; 0x91e <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
     d52:	97 fd       	sbrc	r25, 7
     d54:	27 c0       	rjmp	.+78     	; 0xda4 <iqGetTimeout+0x68>
  while (iqIsEmptyI(iqp)) {
     d56:	8c 81       	ldd	r24, Y+4	; 0x04
     d58:	9d 81       	ldd	r25, Y+5	; 0x05
     d5a:	89 2b       	or	r24, r25
     d5c:	b9 f3       	breq	.-18     	; 0xd4c <iqGetTimeout+0x10>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
     d5e:	8c 81       	ldd	r24, Y+4	; 0x04
     d60:	9d 81       	ldd	r25, Y+5	; 0x05
     d62:	01 97       	sbiw	r24, 0x01	; 1
     d64:	9d 83       	std	Y+5, r25	; 0x05
     d66:	8c 83       	std	Y+4, r24	; 0x04
  b = *iqp->q_rdptr++;
     d68:	ec 85       	ldd	r30, Y+12	; 0x0c
     d6a:	fd 85       	ldd	r31, Y+13	; 0x0d
     d6c:	cf 01       	movw	r24, r30
     d6e:	01 96       	adiw	r24, 0x01	; 1
     d70:	9d 87       	std	Y+13, r25	; 0x0d
     d72:	8c 87       	std	Y+12, r24	; 0x0c
     d74:	10 81       	ld	r17, Z
  if (iqp->q_rdptr >= iqp->q_top) {
     d76:	28 85       	ldd	r18, Y+8	; 0x08
     d78:	39 85       	ldd	r19, Y+9	; 0x09
     d7a:	82 17       	cp	r24, r18
     d7c:	93 07       	cpc	r25, r19
     d7e:	20 f0       	brcs	.+8      	; 0xd88 <iqGetTimeout+0x4c>
    iqp->q_rdptr = iqp->q_buffer;
     d80:	8e 81       	ldd	r24, Y+6	; 0x06
     d82:	9f 81       	ldd	r25, Y+7	; 0x07
     d84:	9d 87       	std	Y+13, r25	; 0x0d
     d86:	8c 87       	std	Y+12, r24	; 0x0c
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
     d88:	ee 85       	ldd	r30, Y+14	; 0x0e
     d8a:	ff 85       	ldd	r31, Y+15	; 0x0f
     d8c:	30 97       	sbiw	r30, 0x00	; 0
     d8e:	11 f0       	breq	.+4      	; 0xd94 <iqGetTimeout+0x58>
    iqp->q_notify(iqp);
     d90:	ce 01       	movw	r24, r28
     d92:	09 95       	icall
  asm volatile ("sei" : : : "memory");
     d94:	78 94       	sei
  }

  osalSysUnlock();

  return (msg_t)b;
     d96:	81 2f       	mov	r24, r17
     d98:	90 e0       	ldi	r25, 0x00	; 0
}
     d9a:	df 91       	pop	r29
     d9c:	cf 91       	pop	r28
     d9e:	1f 91       	pop	r17
     da0:	0f 91       	pop	r16
     da2:	08 95       	ret
     da4:	78 94       	sei
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	1f 91       	pop	r17
     dac:	0f 91       	pop	r16
     dae:	08 95       	ret

00000db0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
     db0:	6f 92       	push	r6
     db2:	7f 92       	push	r7
     db4:	8f 92       	push	r8
     db6:	9f 92       	push	r9
     db8:	af 92       	push	r10
     dba:	bf 92       	push	r11
     dbc:	cf 92       	push	r12
     dbe:	df 92       	push	r13
     dc0:	ef 92       	push	r14
     dc2:	ff 92       	push	r15
     dc4:	0f 93       	push	r16
     dc6:	1f 93       	push	r17
     dc8:	cf 93       	push	r28
     dca:	df 93       	push	r29
     dcc:	4c 01       	movw	r8, r24
     dce:	7b 01       	movw	r14, r22
     dd0:	6a 01       	movw	r12, r20
     dd2:	39 01       	movw	r6, r18
  qnotify_t nfy = iqp->q_notify;
     dd4:	fc 01       	movw	r30, r24
     dd6:	a6 84       	ldd	r10, Z+14	; 0x0e
     dd8:	b7 84       	ldd	r11, Z+15	; 0x0f
  asm volatile ("cli" : : : "memory");
     dda:	f8 94       	cli
  size_t rd = 0;
     ddc:	10 e0       	ldi	r17, 0x00	; 0
     dde:	00 e0       	ldi	r16, 0x00	; 0

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (rd < n) {
     de0:	45 2b       	or	r20, r21
     de2:	81 f4       	brne	.+32     	; 0xe04 <iqReadTimeout+0x54>
     de4:	1b c0       	rjmp	.+54     	; 0xe1c <iqReadTimeout+0x6c>
      }
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
     de6:	a1 14       	cp	r10, r1
     de8:	b1 04       	cpc	r11, r1
     dea:	19 f0       	breq	.+6      	; 0xdf2 <iqReadTimeout+0x42>
        nfy(iqp);
     dec:	c4 01       	movw	r24, r8
     dee:	f5 01       	movw	r30, r10
     df0:	09 95       	icall
  asm volatile ("sei" : : : "memory");
     df2:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      rd += done;
     df4:	0c 0f       	add	r16, r28
     df6:	1d 1f       	adc	r17, r29
      bp += done;
     df8:	ec 0e       	add	r14, r28
     dfa:	fd 1e       	adc	r15, r29
  asm volatile ("cli" : : : "memory");
     dfc:	f8 94       	cli
  while (rd < n) {
     dfe:	0c 15       	cp	r16, r12
     e00:	1d 05       	cpc	r17, r13
     e02:	60 f4       	brcc	.+24     	; 0xe1c <iqReadTimeout+0x6c>
    done = iq_read(iqp, bp, n);
     e04:	a6 01       	movw	r20, r12
     e06:	b7 01       	movw	r22, r14
     e08:	c4 01       	movw	r24, r8
     e0a:	9d de       	rcall	.-710    	; 0xb46 <iq_read>
     e0c:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     e0e:	89 2b       	or	r24, r25
     e10:	51 f7       	brne	.-44     	; 0xde6 <iqReadTimeout+0x36>
     e12:	b3 01       	movw	r22, r6
     e14:	c4 01       	movw	r24, r8
     e16:	83 dd       	rcall	.-1274   	; 0x91e <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
     e18:	89 2b       	or	r24, r25
     e1a:	89 f3       	breq	.-30     	; 0xdfe <iqReadTimeout+0x4e>
  asm volatile ("sei" : : : "memory");
     e1c:	78 94       	sei
    }
  }

  osalSysUnlock();
  return rd;
}
     e1e:	c8 01       	movw	r24, r16
     e20:	df 91       	pop	r29
     e22:	cf 91       	pop	r28
     e24:	1f 91       	pop	r17
     e26:	0f 91       	pop	r16
     e28:	ff 90       	pop	r15
     e2a:	ef 90       	pop	r14
     e2c:	df 90       	pop	r13
     e2e:	cf 90       	pop	r12
     e30:	bf 90       	pop	r11
     e32:	af 90       	pop	r10
     e34:	9f 90       	pop	r9
     e36:	8f 90       	pop	r8
     e38:	7f 90       	pop	r7
     e3a:	6f 90       	pop	r6
     e3c:	08 95       	ret

00000e3e <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
     e3e:	0f 93       	push	r16
     e40:	1f 93       	push	r17
     e42:	fc 01       	movw	r30, r24
  tqp->next = (thread_t *)tqp;
     e44:	91 83       	std	Z+1, r25	; 0x01
     e46:	80 83       	st	Z, r24
  tqp->prev = (thread_t *)tqp;
     e48:	93 83       	std	Z+3, r25	; 0x03
     e4a:	82 83       	std	Z+2, r24	; 0x02

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
     e4c:	55 83       	std	Z+5, r21	; 0x05
     e4e:	44 83       	std	Z+4, r20	; 0x04
  oqp->q_buffer  = bp;
     e50:	77 83       	std	Z+7, r23	; 0x07
     e52:	66 83       	std	Z+6, r22	; 0x06
  oqp->q_rdptr   = bp;
     e54:	75 87       	std	Z+13, r23	; 0x0d
     e56:	64 87       	std	Z+12, r22	; 0x0c
  oqp->q_wrptr   = bp;
     e58:	73 87       	std	Z+11, r23	; 0x0b
     e5a:	62 87       	std	Z+10, r22	; 0x0a
  oqp->q_top     = bp + size;
     e5c:	64 0f       	add	r22, r20
     e5e:	75 1f       	adc	r23, r21
     e60:	71 87       	std	Z+9, r23	; 0x09
     e62:	60 87       	std	Z+8, r22	; 0x08
  oqp->q_notify  = onfy;
     e64:	37 87       	std	Z+15, r19	; 0x0f
     e66:	26 87       	std	Z+14, r18	; 0x0e
  oqp->q_link    = link;
     e68:	11 8b       	std	Z+17, r17	; 0x11
     e6a:	00 8b       	std	Z+16, r16	; 0x10
}
     e6c:	1f 91       	pop	r17
     e6e:	0f 91       	pop	r16
     e70:	08 95       	ret

00000e72 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
     e72:	ff 92       	push	r15
     e74:	0f 93       	push	r16
     e76:	1f 93       	push	r17
     e78:	cf 93       	push	r28
     e7a:	df 93       	push	r29
     e7c:	ec 01       	movw	r28, r24
     e7e:	f6 2e       	mov	r15, r22
     e80:	8a 01       	movw	r16, r20
  asm volatile ("cli" : : : "memory");
     e82:	f8 94       	cli
     e84:	05 c0       	rjmp	.+10     	; 0xe90 <oqPutTimeout+0x1e>
     e86:	b8 01       	movw	r22, r16
     e88:	ce 01       	movw	r24, r28
     e8a:	49 dd       	rcall	.-1390   	; 0x91e <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
     e8c:	97 fd       	sbrc	r25, 7
     e8e:	2a c0       	rjmp	.+84     	; 0xee4 <oqPutTimeout+0x72>
  while (oqIsFullI(oqp)) {
     e90:	8c 81       	ldd	r24, Y+4	; 0x04
     e92:	9d 81       	ldd	r25, Y+5	; 0x05
     e94:	89 2b       	or	r24, r25
     e96:	b9 f3       	breq	.-18     	; 0xe86 <oqPutTimeout+0x14>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
     e98:	8c 81       	ldd	r24, Y+4	; 0x04
     e9a:	9d 81       	ldd	r25, Y+5	; 0x05
     e9c:	01 97       	sbiw	r24, 0x01	; 1
     e9e:	9d 83       	std	Y+5, r25	; 0x05
     ea0:	8c 83       	std	Y+4, r24	; 0x04
  *oqp->q_wrptr++ = b;
     ea2:	ea 85       	ldd	r30, Y+10	; 0x0a
     ea4:	fb 85       	ldd	r31, Y+11	; 0x0b
     ea6:	cf 01       	movw	r24, r30
     ea8:	01 96       	adiw	r24, 0x01	; 1
     eaa:	9b 87       	std	Y+11, r25	; 0x0b
     eac:	8a 87       	std	Y+10, r24	; 0x0a
     eae:	f0 82       	st	Z, r15
  if (oqp->q_wrptr >= oqp->q_top) {
     eb0:	2a 85       	ldd	r18, Y+10	; 0x0a
     eb2:	3b 85       	ldd	r19, Y+11	; 0x0b
     eb4:	88 85       	ldd	r24, Y+8	; 0x08
     eb6:	99 85       	ldd	r25, Y+9	; 0x09
     eb8:	28 17       	cp	r18, r24
     eba:	39 07       	cpc	r19, r25
     ebc:	20 f0       	brcs	.+8      	; 0xec6 <oqPutTimeout+0x54>
    oqp->q_wrptr = oqp->q_buffer;
     ebe:	8e 81       	ldd	r24, Y+6	; 0x06
     ec0:	9f 81       	ldd	r25, Y+7	; 0x07
     ec2:	9b 87       	std	Y+11, r25	; 0x0b
     ec4:	8a 87       	std	Y+10, r24	; 0x0a
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
     ec6:	ee 85       	ldd	r30, Y+14	; 0x0e
     ec8:	ff 85       	ldd	r31, Y+15	; 0x0f
     eca:	30 97       	sbiw	r30, 0x00	; 0
     ecc:	11 f0       	breq	.+4      	; 0xed2 <oqPutTimeout+0x60>
    oqp->q_notify(oqp);
     ece:	ce 01       	movw	r24, r28
     ed0:	09 95       	icall
  asm volatile ("sei" : : : "memory");
     ed2:	78 94       	sei
  }

  osalSysUnlock();

  return MSG_OK;
     ed4:	90 e0       	ldi	r25, 0x00	; 0
     ed6:	80 e0       	ldi	r24, 0x00	; 0
}
     ed8:	df 91       	pop	r29
     eda:	cf 91       	pop	r28
     edc:	1f 91       	pop	r17
     ede:	0f 91       	pop	r16
     ee0:	ff 90       	pop	r15
     ee2:	08 95       	ret
     ee4:	78 94       	sei
     ee6:	df 91       	pop	r29
     ee8:	cf 91       	pop	r28
     eea:	1f 91       	pop	r17
     eec:	0f 91       	pop	r16
     eee:	ff 90       	pop	r15
     ef0:	08 95       	ret

00000ef2 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
     ef2:	cf 93       	push	r28
     ef4:	fc 01       	movw	r30, r24

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
     ef6:	a4 85       	ldd	r26, Z+12	; 0x0c
     ef8:	b5 85       	ldd	r27, Z+13	; 0x0d
     efa:	82 85       	ldd	r24, Z+10	; 0x0a
     efc:	93 85       	ldd	r25, Z+11	; 0x0b
     efe:	8a 17       	cp	r24, r26
     f00:	9b 07       	cpc	r25, r27
     f02:	e1 f0       	breq	.+56     	; 0xf3c <oqGetI+0x4a>
    uint8_t b;

    oqp->q_counter++;
     f04:	84 81       	ldd	r24, Z+4	; 0x04
     f06:	95 81       	ldd	r25, Z+5	; 0x05
     f08:	01 96       	adiw	r24, 0x01	; 1
     f0a:	95 83       	std	Z+5, r25	; 0x05
     f0c:	84 83       	std	Z+4, r24	; 0x04
    b = *oqp->q_rdptr++;
     f0e:	cd 01       	movw	r24, r26
     f10:	01 96       	adiw	r24, 0x01	; 1
     f12:	95 87       	std	Z+13, r25	; 0x0d
     f14:	84 87       	std	Z+12, r24	; 0x0c
     f16:	cc 91       	ld	r28, X
    if (oqp->q_rdptr >= oqp->q_top) {
     f18:	20 85       	ldd	r18, Z+8	; 0x08
     f1a:	31 85       	ldd	r19, Z+9	; 0x09
     f1c:	82 17       	cp	r24, r18
     f1e:	93 07       	cpc	r25, r19
     f20:	40 f4       	brcc	.+16     	; 0xf32 <oqGetI+0x40>
  chThdDequeueNextI(tqp, msg);
     f22:	70 e0       	ldi	r23, 0x00	; 0
     f24:	60 e0       	ldi	r22, 0x00	; 0
     f26:	cf 01       	movw	r24, r30
     f28:	17 dd       	rcall	.-1490   	; 0x958 <chThdDequeueNextI>
      oqp->q_rdptr = oqp->q_buffer;
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);

    return (msg_t)b;
     f2a:	8c 2f       	mov	r24, r28
     f2c:	90 e0       	ldi	r25, 0x00	; 0
  }

  return MSG_TIMEOUT;
}
     f2e:	cf 91       	pop	r28
     f30:	08 95       	ret
      oqp->q_rdptr = oqp->q_buffer;
     f32:	86 81       	ldd	r24, Z+6	; 0x06
     f34:	97 81       	ldd	r25, Z+7	; 0x07
     f36:	95 87       	std	Z+13, r25	; 0x0d
     f38:	84 87       	std	Z+12, r24	; 0x0c
     f3a:	f3 cf       	rjmp	.-26     	; 0xf22 <oqGetI+0x30>
  if (!oqIsEmptyI(oqp)) {
     f3c:	84 81       	ldd	r24, Z+4	; 0x04
     f3e:	95 81       	ldd	r25, Z+5	; 0x05
     f40:	89 2b       	or	r24, r25
     f42:	01 f3       	breq	.-64     	; 0xf04 <oqGetI+0x12>
  return MSG_TIMEOUT;
     f44:	8f ef       	ldi	r24, 0xFF	; 255
     f46:	9f ef       	ldi	r25, 0xFF	; 255
}
     f48:	cf 91       	pop	r28
     f4a:	08 95       	ret

00000f4c <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
     f4c:	6f 92       	push	r6
     f4e:	7f 92       	push	r7
     f50:	8f 92       	push	r8
     f52:	9f 92       	push	r9
     f54:	af 92       	push	r10
     f56:	bf 92       	push	r11
     f58:	cf 92       	push	r12
     f5a:	df 92       	push	r13
     f5c:	ef 92       	push	r14
     f5e:	ff 92       	push	r15
     f60:	0f 93       	push	r16
     f62:	1f 93       	push	r17
     f64:	cf 93       	push	r28
     f66:	df 93       	push	r29
     f68:	4c 01       	movw	r8, r24
     f6a:	7b 01       	movw	r14, r22
     f6c:	6a 01       	movw	r12, r20
     f6e:	39 01       	movw	r6, r18
  qnotify_t nfy = oqp->q_notify;
     f70:	fc 01       	movw	r30, r24
     f72:	a6 84       	ldd	r10, Z+14	; 0x0e
     f74:	b7 84       	ldd	r11, Z+15	; 0x0f
  asm volatile ("cli" : : : "memory");
     f76:	f8 94       	cli
  size_t wr = 0;
     f78:	10 e0       	ldi	r17, 0x00	; 0
     f7a:	00 e0       	ldi	r16, 0x00	; 0

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (wr < n) {
     f7c:	45 2b       	or	r20, r21
     f7e:	81 f4       	brne	.+32     	; 0xfa0 <oqWriteTimeout+0x54>
     f80:	1b c0       	rjmp	.+54     	; 0xfb8 <oqWriteTimeout+0x6c>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
     f82:	a1 14       	cp	r10, r1
     f84:	b1 04       	cpc	r11, r1
     f86:	19 f0       	breq	.+6      	; 0xf8e <oqWriteTimeout+0x42>
        nfy(oqp);
     f88:	c4 01       	movw	r24, r8
     f8a:	f5 01       	movw	r30, r10
     f8c:	09 95       	icall
  asm volatile ("sei" : : : "memory");
     f8e:	78 94       	sei
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      wr += done;
     f90:	0c 0f       	add	r16, r28
     f92:	1d 1f       	adc	r17, r29
      bp += done;
     f94:	ec 0e       	add	r14, r28
     f96:	fd 1e       	adc	r15, r29
  asm volatile ("cli" : : : "memory");
     f98:	f8 94       	cli
  while (wr < n) {
     f9a:	0c 15       	cp	r16, r12
     f9c:	1d 05       	cpc	r17, r13
     f9e:	60 f4       	brcc	.+24     	; 0xfb8 <oqWriteTimeout+0x6c>
    done = oq_write(oqp, bp, n);
     fa0:	a6 01       	movw	r20, r12
     fa2:	b7 01       	movw	r22, r14
     fa4:	c4 01       	movw	r24, r8
     fa6:	2a de       	rcall	.-940    	; 0xbfc <oq_write>
     fa8:	ec 01       	movw	r28, r24
    if (done == (size_t)0) {
     faa:	89 2b       	or	r24, r25
     fac:	51 f7       	brne	.-44     	; 0xf82 <oqWriteTimeout+0x36>
  return chThdEnqueueTimeoutS(tqp, timeout);
     fae:	b3 01       	movw	r22, r6
     fb0:	c4 01       	movw	r24, r8
     fb2:	b5 dc       	rcall	.-1686   	; 0x91e <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
     fb4:	89 2b       	or	r24, r25
     fb6:	89 f3       	breq	.-30     	; 0xf9a <oqWriteTimeout+0x4e>
  asm volatile ("sei" : : : "memory");
     fb8:	78 94       	sei
    }
  }

  osalSysUnlock();
  return wr;
}
     fba:	c8 01       	movw	r24, r16
     fbc:	df 91       	pop	r29
     fbe:	cf 91       	pop	r28
     fc0:	1f 91       	pop	r17
     fc2:	0f 91       	pop	r16
     fc4:	ff 90       	pop	r15
     fc6:	ef 90       	pop	r14
     fc8:	df 90       	pop	r13
     fca:	cf 90       	pop	r12
     fcc:	bf 90       	pop	r11
     fce:	af 90       	pop	r10
     fd0:	9f 90       	pop	r9
     fd2:	8f 90       	pop	r8
     fd4:	7f 90       	pop	r7
     fd6:	6f 90       	pop	r6
     fd8:	08 95       	ret

00000fda <adcInit>:
 *
 * @init
 */
void adcInit(void) {

  adc_lld_init();
     fda:	dd c1       	rjmp	.+954    	; 0x1396 <adc_lld_init>

00000fdc <adcObjectInit>:
 *
 * @param[out] adcp     pointer to the @p ADCDriver object
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {
     fdc:	fc 01       	movw	r30, r24

  adcp->state    = ADC_STOP;
     fde:	81 e0       	ldi	r24, 0x01	; 1
     fe0:	80 83       	st	Z, r24
  adcp->config   = NULL;
     fe2:	12 82       	std	Z+2, r1	; 0x02
     fe4:	11 82       	std	Z+1, r1	; 0x01
  adcp->samples  = NULL;
     fe6:	14 82       	std	Z+4, r1	; 0x04
     fe8:	13 82       	std	Z+3, r1	; 0x03
  adcp->depth    = 0;
     fea:	16 82       	std	Z+6, r1	; 0x06
     fec:	15 82       	std	Z+5, r1	; 0x05
  adcp->grpp     = NULL;
     fee:	10 86       	std	Z+8, r1	; 0x08
     ff0:	17 82       	std	Z+7, r1	; 0x07
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
     ff2:	12 86       	std	Z+10, r1	; 0x0a
     ff4:	11 86       	std	Z+9, r1	; 0x09
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
     ff6:	cf 01       	movw	r24, r30
     ff8:	0b 96       	adiw	r24, 0x0b	; 11
     ffa:	c7 cc       	rjmp	.-1650   	; 0x98a <chMtxObjectInit>

00000ffc <adcStart>:
 * @param[in] config    pointer to the @p ADCConfig object. Depending on
 *                      the implementation the value can be @p NULL.
 *
 * @api
 */
void adcStart(ADCDriver *adcp, const ADCConfig *config) {
     ffc:	cf 93       	push	r28
     ffe:	df 93       	push	r29
    1000:	ec 01       	movw	r28, r24
  asm volatile ("cli" : : : "memory");
    1002:	f8 94       	cli
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
    1004:	7a 83       	std	Y+2, r23	; 0x02
    1006:	69 83       	std	Y+1, r22	; 0x01
  adc_lld_start(adcp);
    1008:	cf d1       	rcall	.+926    	; 0x13a8 <adc_lld_start>
  adcp->state = ADC_READY;
    100a:	82 e0       	ldi	r24, 0x02	; 2
    100c:	88 83       	st	Y, r24
  asm volatile ("sei" : : : "memory");
    100e:	78 94       	sei
  osalSysUnlock();
}
    1010:	df 91       	pop	r29
    1012:	cf 91       	pop	r28
    1014:	08 95       	ret

00001016 <adcStartConversion>:
  asm volatile ("cli" : : : "memory");
    1016:	f8 94       	cli
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
    1018:	fc 01       	movw	r30, r24
    101a:	54 83       	std	Z+4, r21	; 0x04
    101c:	43 83       	std	Z+3, r20	; 0x03
  adcp->depth    = depth;
    101e:	36 83       	std	Z+6, r19	; 0x06
    1020:	25 83       	std	Z+5, r18	; 0x05
  adcp->grpp     = grpp;
    1022:	70 87       	std	Z+8, r23	; 0x08
    1024:	67 83       	std	Z+7, r22	; 0x07
  adcp->state    = ADC_ACTIVE;
    1026:	23 e0       	ldi	r18, 0x03	; 3
    1028:	20 83       	st	Z, r18
  adc_lld_start_conversion(adcp);
    102a:	d5 d1       	rcall	.+938    	; 0x13d6 <adc_lld_start_conversion>
  asm volatile ("sei" : : : "memory");
    102c:	78 94       	sei
}
    102e:	08 95       	ret

00001030 <_readt>:
}

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    1030:	05 96       	adiw	r24, 0x05	; 5
    1032:	be ce       	rjmp	.-644    	; 0xdb0 <iqReadTimeout>

00001034 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    1034:	2f ef       	ldi	r18, 0xFF	; 255
    1036:	3f ef       	ldi	r19, 0xFF	; 255
    1038:	05 96       	adiw	r24, 0x05	; 5
    103a:	ba ce       	rjmp	.-652    	; 0xdb0 <iqReadTimeout>

0000103c <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    103c:	47 96       	adiw	r24, 0x17	; 23
    103e:	86 cf       	rjmp	.-244    	; 0xf4c <oqWriteTimeout>

00001040 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    1040:	2f ef       	ldi	r18, 0xFF	; 255
    1042:	3f ef       	ldi	r19, 0xFF	; 255
    1044:	47 96       	adiw	r24, 0x17	; 23
    1046:	82 cf       	rjmp	.-252    	; 0xf4c <oqWriteTimeout>

00001048 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    1048:	05 96       	adiw	r24, 0x05	; 5
    104a:	78 ce       	rjmp	.-784    	; 0xd3c <iqGetTimeout>

0000104c <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    104c:	6f ef       	ldi	r22, 0xFF	; 255
    104e:	7f ef       	ldi	r23, 0xFF	; 255
    1050:	05 96       	adiw	r24, 0x05	; 5
    1052:	74 ce       	rjmp	.-792    	; 0xd3c <iqGetTimeout>

00001054 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    1054:	47 96       	adiw	r24, 0x17	; 23
    1056:	0d cf       	rjmp	.-486    	; 0xe72 <oqPutTimeout>

00001058 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    1058:	4f ef       	ldi	r20, 0xFF	; 255
    105a:	5f ef       	ldi	r21, 0xFF	; 255
    105c:	47 96       	adiw	r24, 0x17	; 23
    105e:	09 cf       	rjmp	.-494    	; 0xe72 <oqPutTimeout>

00001060 <_ctl>:
    1060:	90 e0       	ldi	r25, 0x00	; 0
    1062:	80 e0       	ldi	r24, 0x00	; 0
    1064:	08 95       	ret

00001066 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    1066:	d6 c2       	rjmp	.+1452   	; 0x1614 <sd_lld_init>

00001068 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    1068:	ef 92       	push	r14
    106a:	ff 92       	push	r15
    106c:	0f 93       	push	r16
    106e:	1f 93       	push	r17
    1070:	cf 93       	push	r28
    1072:	df 93       	push	r29
    1074:	ec 01       	movw	r28, r24
    1076:	9b 01       	movw	r18, r22
    1078:	7a 01       	movw	r14, r20

  sdp->vmt = &vmt;
    107a:	fc 01       	movw	r30, r24
    107c:	83 e3       	ldi	r24, 0x33	; 51
    107e:	91 e0       	ldi	r25, 0x01	; 1
    1080:	81 93       	st	Z+, r24
    1082:	91 93       	st	Z+, r25
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
    1084:	fb 83       	std	Y+3, r31	; 0x03
    1086:	ea 83       	std	Y+2, r30	; 0x02
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
    1088:	81 e0       	ldi	r24, 0x01	; 1
    108a:	8c 83       	std	Y+4, r24	; 0x04
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    108c:	be 01       	movw	r22, r28
    108e:	67 5d       	subi	r22, 0xD7	; 215
    1090:	7f 4f       	sbci	r23, 0xFF	; 255
    1092:	8e 01       	movw	r16, r28
    1094:	40 e1       	ldi	r20, 0x10	; 16
    1096:	50 e0       	ldi	r21, 0x00	; 0
    1098:	ce 01       	movw	r24, r28
    109a:	05 96       	adiw	r24, 0x05	; 5
    109c:	0a de       	rcall	.-1004   	; 0xcb2 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    109e:	be 01       	movw	r22, r28
    10a0:	67 5c       	subi	r22, 0xC7	; 199
    10a2:	7f 4f       	sbci	r23, 0xFF	; 255
    10a4:	97 01       	movw	r18, r14
    10a6:	40 e1       	ldi	r20, 0x10	; 16
    10a8:	50 e0       	ldi	r21, 0x00	; 0
    10aa:	ce 01       	movw	r24, r28
    10ac:	47 96       	adiw	r24, 0x17	; 23
    10ae:	c7 de       	rcall	.-626    	; 0xe3e <oqObjectInit>
}
    10b0:	df 91       	pop	r29
    10b2:	cf 91       	pop	r28
    10b4:	1f 91       	pop	r17
    10b6:	0f 91       	pop	r16
    10b8:	ff 90       	pop	r15
    10ba:	ef 90       	pop	r14
    10bc:	08 95       	ret

000010be <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    10be:	cf 93       	push	r28
    10c0:	df 93       	push	r29
    10c2:	ec 01       	movw	r28, r24
  asm volatile ("cli" : : : "memory");
    10c4:	f8 94       	cli
  osalDbgCheck(sdp != NULL);

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    10c6:	ad d2       	rcall	.+1370   	; 0x1622 <sd_lld_start>
  sdp->state = SD_READY;
    10c8:	82 e0       	ldi	r24, 0x02	; 2
    10ca:	8c 83       	std	Y+4, r24	; 0x04
  asm volatile ("sei" : : : "memory");
    10cc:	78 94       	sei
  osalSysUnlock();
}
    10ce:	df 91       	pop	r29
    10d0:	cf 91       	pop	r28
    10d2:	08 95       	ret

000010d4 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    10d4:	1f 93       	push	r17
    10d6:	cf 93       	push	r28
    10d8:	df 93       	push	r29
    10da:	ec 01       	movw	r28, r24
    10dc:	16 2f       	mov	r17, r22

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    10de:	89 85       	ldd	r24, Y+9	; 0x09
    10e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    10e2:	89 2b       	or	r24, r25
    10e4:	51 f0       	breq	.+20     	; 0x10fa <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    10e6:	61 2f       	mov	r22, r17
    10e8:	ce 01       	movw	r24, r28
    10ea:	05 96       	adiw	r24, 0x05	; 5
    10ec:	fc dd       	rcall	.-1032   	; 0xce6 <iqPutI>
    10ee:	97 fd       	sbrc	r25, 7
    10f0:	0e c0       	rjmp	.+28     	; 0x110e <sdIncomingDataI+0x3a>
    chnAddFlagsI(sdp, SD_QUEUE_FULL_ERROR);
}
    10f2:	df 91       	pop	r29
    10f4:	cf 91       	pop	r28
    10f6:	1f 91       	pop	r17
    10f8:	08 95       	ret
  chEvtBroadcastFlagsI(esp, flags);
    10fa:	64 e0       	ldi	r22, 0x04	; 4
    10fc:	ce 01       	movw	r24, r28
    10fe:	02 96       	adiw	r24, 0x02	; 2
    1100:	62 dc       	rcall	.-1852   	; 0x9c6 <chEvtBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    1102:	61 2f       	mov	r22, r17
    1104:	ce 01       	movw	r24, r28
    1106:	05 96       	adiw	r24, 0x05	; 5
    1108:	ee dd       	rcall	.-1060   	; 0xce6 <iqPutI>
    110a:	97 ff       	sbrs	r25, 7
    110c:	f2 cf       	rjmp	.-28     	; 0x10f2 <sdIncomingDataI+0x1e>
    110e:	60 e0       	ldi	r22, 0x00	; 0
    1110:	ce 01       	movw	r24, r28
    1112:	02 96       	adiw	r24, 0x02	; 2
}
    1114:	df 91       	pop	r29
    1116:	cf 91       	pop	r28
    1118:	1f 91       	pop	r17
    111a:	55 cc       	rjmp	.-1878   	; 0x9c6 <chEvtBroadcastFlagsI>

0000111c <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    111c:	0f 93       	push	r16
    111e:	1f 93       	push	r17
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	8c 01       	movw	r16, r24
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    1126:	47 96       	adiw	r24, 0x17	; 23
    1128:	e4 de       	rcall	.-568    	; 0xef2 <oqGetI>
    112a:	ec 01       	movw	r28, r24
  if (b < MSG_OK)
    112c:	97 fd       	sbrc	r25, 7
    112e:	06 c0       	rjmp	.+12     	; 0x113c <sdRequestDataI+0x20>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
  return b;
}
    1130:	ce 01       	movw	r24, r28
    1132:	df 91       	pop	r29
    1134:	cf 91       	pop	r28
    1136:	1f 91       	pop	r17
    1138:	0f 91       	pop	r16
    113a:	08 95       	ret
    113c:	68 e0       	ldi	r22, 0x08	; 8
    113e:	c8 01       	movw	r24, r16
    1140:	02 96       	adiw	r24, 0x02	; 2
    1142:	41 dc       	rcall	.-1918   	; 0x9c6 <chEvtBroadcastFlagsI>
    1144:	ce 01       	movw	r24, r28
    1146:	df 91       	pop	r29
    1148:	cf 91       	pop	r28
    114a:	1f 91       	pop	r17
    114c:	0f 91       	pop	r16
    114e:	08 95       	ret

00001150 <hal_lld_init>:
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
}
    1150:	08 95       	ret

00001152 <__vector_21>:
/* Driver interrupt handlers.                                               */
/*==========================================================================*/

#include <util/delay.h>

OSAL_IRQ_HANDLER(ADC_vect) {
    1152:	1f 92       	push	r1
    1154:	0f 92       	push	r0
    1156:	0f b6       	in	r0, 0x3f	; 63
    1158:	0f 92       	push	r0
    115a:	11 24       	eor	r1, r1
    115c:	af 92       	push	r10
    115e:	bf 92       	push	r11
    1160:	cf 92       	push	r12
    1162:	df 92       	push	r13
    1164:	ef 92       	push	r14
    1166:	ff 92       	push	r15
    1168:	0f 93       	push	r16
    116a:	1f 93       	push	r17
    116c:	2f 93       	push	r18
    116e:	3f 93       	push	r19
    1170:	4f 93       	push	r20
    1172:	5f 93       	push	r21
    1174:	6f 93       	push	r22
    1176:	7f 93       	push	r23
    1178:	8f 93       	push	r24
    117a:	9f 93       	push	r25
    117c:	af 93       	push	r26
    117e:	bf 93       	push	r27
    1180:	cf 93       	push	r28
    1182:	df 93       	push	r29
    1184:	ef 93       	push	r30
    1186:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
    1188:	81 e0       	ldi	r24, 0x01	; 1
    118a:	80 93 61 03 	sts	0x0361, r24	; 0x800361 <__avr_in_isr>
  uint8_t low = ADCL;
    118e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
  uint8_t high = ADCH;
    1192:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
  uint16_t result = (high << 8) | low;

  ADCD1.samples[ADCD1.currentBufferPosition] = result;
    1196:	00 91 65 03 	lds	r16, 0x0365	; 0x800365 <ADCD1+0x3>
    119a:	10 91 66 03 	lds	r17, 0x0366	; 0x800366 <ADCD1+0x4>
    119e:	e0 91 75 03 	lds	r30, 0x0375	; 0x800375 <ADCD1+0x13>
    11a2:	f0 91 76 03 	lds	r31, 0x0376	; 0x800376 <ADCD1+0x14>
    11a6:	ee 0f       	add	r30, r30
    11a8:	ff 1f       	adc	r31, r31
    11aa:	e0 0f       	add	r30, r16
    11ac:	f1 1f       	adc	r31, r17
    11ae:	91 83       	std	Z+1, r25	; 0x01
    11b0:	80 83       	st	Z, r24
  ADCD1.currentBufferPosition++;
    11b2:	20 91 75 03 	lds	r18, 0x0375	; 0x800375 <ADCD1+0x13>
    11b6:	30 91 76 03 	lds	r19, 0x0376	; 0x800376 <ADCD1+0x14>
    11ba:	2f 5f       	subi	r18, 0xFF	; 255
    11bc:	3f 4f       	sbci	r19, 0xFF	; 255
    11be:	30 93 76 03 	sts	0x0376, r19	; 0x800376 <ADCD1+0x14>
    11c2:	20 93 75 03 	sts	0x0375, r18	; 0x800375 <ADCD1+0x13>

  size_t bufferSize = ADCD1.depth * ADCD1.grpp->num_channels;
    11c6:	a0 90 67 03 	lds	r10, 0x0367	; 0x800367 <ADCD1+0x5>
    11ca:	b0 90 68 03 	lds	r11, 0x0368	; 0x800368 <ADCD1+0x6>
    11ce:	e0 91 69 03 	lds	r30, 0x0369	; 0x800369 <ADCD1+0x7>
    11d2:	f0 91 6a 03 	lds	r31, 0x036A	; 0x80036a <ADCD1+0x8>
    11d6:	6f 01       	movw	r12, r30
    11d8:	61 81       	ldd	r22, Z+1	; 0x01
    11da:	72 81       	ldd	r23, Z+2	; 0x02
    11dc:	a6 9e       	mul	r10, r22
    11de:	70 01       	movw	r14, r0
    11e0:	a7 9e       	mul	r10, r23
    11e2:	f0 0c       	add	r15, r0
    11e4:	b6 9e       	mul	r11, r22
    11e6:	f0 0c       	add	r15, r0
    11e8:	11 24       	eor	r1, r1
  size_t currentChannel = ADCD1.currentBufferPosition % ADCD1.grpp->num_channels;
    11ea:	c9 01       	movw	r24, r18
    11ec:	aa d5       	rcall	.+2900   	; 0x1d42 <__udivmodhi4>
    11ee:	ec 01       	movw	r28, r24
  size_t currentIteration = ADCD1.currentBufferPosition / ADCD1.grpp->num_channels;
  if (ADCD1.grpp->circular && currentChannel == 0 && currentIteration == ADCD1.depth/2) {
    11f0:	80 81       	ld	r24, Z
    11f2:	88 23       	and	r24, r24
    11f4:	09 f4       	brne	.+2      	; 0x11f8 <__vector_21+0xa6>
    11f6:	47 c0       	rjmp	.+142    	; 0x1286 <__vector_21+0x134>
    11f8:	20 97       	sbiw	r28, 0x00	; 0
    11fa:	31 f4       	brne	.+12     	; 0x1208 <__vector_21+0xb6>
    11fc:	b6 94       	lsr	r11
    11fe:	a7 94       	ror	r10
    1200:	a6 16       	cp	r10, r22
    1202:	b7 06       	cpc	r11, r23
    1204:	09 f4       	brne	.+2      	; 0x1208 <__vector_21+0xb6>
    1206:	70 c0       	rjmp	.+224    	; 0x12e8 <__vector_21+0x196>
    _adc_isr_half_code(&ADCD1);
  }

  if (ADCD1.currentBufferPosition == bufferSize) {
    1208:	2e 15       	cp	r18, r14
    120a:	3f 05       	cpc	r19, r15
    120c:	09 f4       	brne	.+2      	; 0x1210 <__vector_21+0xbe>
    120e:	8b c0       	rjmp	.+278    	; 0x1326 <__vector_21+0x1d4>
    _adc_isr_full_code(&ADCD1);
  }
  else {
    setAdcChannel(getAdcChannelNumberFromMask(ADCD1.grpp->channelsMask,currentChannel));
    1210:	f6 01       	movw	r30, r12
    1212:	95 81       	ldd	r25, Z+5	; 0x05
  for (uint8_t i = 0; mask > 0; i++) {
    1214:	99 23       	and	r25, r25
    1216:	59 f0       	breq	.+22     	; 0x122e <__vector_21+0xdc>
    1218:	20 e0       	ldi	r18, 0x00	; 0
    if (mask & 0x01) {
    121a:	90 ff       	sbrs	r25, 0
    121c:	04 c0       	rjmp	.+8      	; 0x1226 <__vector_21+0xd4>
      if (!currentChannel)
    121e:	cc 23       	and	r28, r28
    1220:	09 f4       	brne	.+2      	; 0x1224 <__vector_21+0xd2>
    1222:	60 c0       	rjmp	.+192    	; 0x12e4 <__vector_21+0x192>
      currentChannel--;
    1224:	c1 50       	subi	r28, 0x01	; 1
    mask >>= 1;
    1226:	96 95       	lsr	r25
  for (uint8_t i = 0; mask > 0; i++) {
    1228:	2f 5f       	subi	r18, 0xFF	; 255
    122a:	91 11       	cpse	r25, r1
    122c:	f6 cf       	rjmp	.-20     	; 0x121a <__vector_21+0xc8>
    122e:	27 e0       	ldi	r18, 0x07	; 7
  ADMUX = (ADMUX & 0xf8) | (channelNum & 0x07);
    1230:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
    1234:	88 7f       	andi	r24, 0xF8	; 248
    1236:	28 2b       	or	r18, r24
    1238:	20 93 7c 00 	sts	0x007C, r18	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
    ADCSRA |= 1 << ADSC;
    123c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
    1240:	80 64       	ori	r24, 0x40	; 64
    1242:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
  }

  OSAL_IRQ_EPILOGUE();
    1246:	10 92 61 03 	sts	0x0361, r1	; 0x800361 <__avr_in_isr>
    124a:	fd d9       	rcall	.-3078   	; 0x646 <chSchIsPreemptionRequired>
    124c:	81 11       	cpse	r24, r1
    124e:	48 c0       	rjmp	.+144    	; 0x12e0 <__vector_21+0x18e>
}
    1250:	ff 91       	pop	r31
    1252:	ef 91       	pop	r30
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	bf 91       	pop	r27
    125a:	af 91       	pop	r26
    125c:	9f 91       	pop	r25
    125e:	8f 91       	pop	r24
    1260:	7f 91       	pop	r23
    1262:	6f 91       	pop	r22
    1264:	5f 91       	pop	r21
    1266:	4f 91       	pop	r20
    1268:	3f 91       	pop	r19
    126a:	2f 91       	pop	r18
    126c:	1f 91       	pop	r17
    126e:	0f 91       	pop	r16
    1270:	ff 90       	pop	r15
    1272:	ef 90       	pop	r14
    1274:	df 90       	pop	r13
    1276:	cf 90       	pop	r12
    1278:	bf 90       	pop	r11
    127a:	af 90       	pop	r10
    127c:	0f 90       	pop	r0
    127e:	0f be       	out	0x3f, r0	; 63
    1280:	0f 90       	pop	r0
    1282:	1f 90       	pop	r1
    1284:	18 95       	reti
  if (ADCD1.currentBufferPosition == bufferSize) {
    1286:	2e 15       	cp	r18, r14
    1288:	3f 05       	cpc	r19, r15
    128a:	09 f0       	breq	.+2      	; 0x128e <__vector_21+0x13c>
    128c:	c1 cf       	rjmp	.-126    	; 0x1210 <__vector_21+0xbe>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  ADCSRA &= ~(1 << ADSC);
    128e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
    1292:	8f 7b       	andi	r24, 0xBF	; 191
    1294:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
    _adc_isr_full_code(&ADCD1);
    1298:	03 80       	ldd	r0, Z+3	; 0x03
    129a:	f4 81       	ldd	r31, Z+4	; 0x04
    129c:	e0 2d       	mov	r30, r0
    129e:	30 97       	sbiw	r30, 0x00	; 0
    12a0:	09 f4       	brne	.+2      	; 0x12a4 <__vector_21+0x152>
    12a2:	67 c0       	rjmp	.+206    	; 0x1372 <__vector_21+0x220>
    12a4:	84 e0       	ldi	r24, 0x04	; 4
    12a6:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <ADCD1>
    12aa:	40 91 67 03 	lds	r20, 0x0367	; 0x800367 <ADCD1+0x5>
    12ae:	50 91 68 03 	lds	r21, 0x0368	; 0x800368 <ADCD1+0x6>
    12b2:	60 91 65 03 	lds	r22, 0x0365	; 0x800365 <ADCD1+0x3>
    12b6:	70 91 66 03 	lds	r23, 0x0366	; 0x800366 <ADCD1+0x4>
    12ba:	82 e6       	ldi	r24, 0x62	; 98
    12bc:	93 e0       	ldi	r25, 0x03	; 3
    12be:	09 95       	icall
    12c0:	80 91 62 03 	lds	r24, 0x0362	; 0x800362 <ADCD1>
    12c4:	84 30       	cpi	r24, 0x04	; 4
    12c6:	09 f4       	brne	.+2      	; 0x12ca <__vector_21+0x178>
    12c8:	54 c0       	rjmp	.+168    	; 0x1372 <__vector_21+0x220>
  chThdResumeI(trp, msg);
    12ca:	70 e0       	ldi	r23, 0x00	; 0
    12cc:	60 e0       	ldi	r22, 0x00	; 0
    12ce:	8b e6       	ldi	r24, 0x6B	; 107
    12d0:	93 e0       	ldi	r25, 0x03	; 3
  OSAL_IRQ_EPILOGUE();
    12d2:	18 db       	rcall	.-2512   	; 0x904 <chThdResumeI>
    12d4:	10 92 61 03 	sts	0x0361, r1	; 0x800361 <__avr_in_isr>
    12d8:	b6 d9       	rcall	.-3220   	; 0x646 <chSchIsPreemptionRequired>
    12da:	88 23       	and	r24, r24
    12dc:	09 f4       	brne	.+2      	; 0x12e0 <__vector_21+0x18e>
    12de:	b8 cf       	rjmp	.-144    	; 0x1250 <__vector_21+0xfe>
    12e0:	ff d9       	rcall	.-3074   	; 0x6e0 <chSchDoReschedule>
}
    12e2:	b6 cf       	rjmp	.-148    	; 0x1250 <__vector_21+0xfe>
        return i;
    12e4:	27 70       	andi	r18, 0x07	; 7
    12e6:	a4 cf       	rjmp	.-184    	; 0x1230 <__vector_21+0xde>
    _adc_isr_half_code(&ADCD1);
    12e8:	03 80       	ldd	r0, Z+3	; 0x03
    12ea:	f4 81       	ldd	r31, Z+4	; 0x04
    12ec:	e0 2d       	mov	r30, r0
    12ee:	30 97       	sbiw	r30, 0x00	; 0
    12f0:	09 f4       	brne	.+2      	; 0x12f4 <__vector_21+0x1a2>
    12f2:	4c c0       	rjmp	.+152    	; 0x138c <__vector_21+0x23a>
    12f4:	a5 01       	movw	r20, r10
    12f6:	b8 01       	movw	r22, r16
    12f8:	82 e6       	ldi	r24, 0x62	; 98
    12fa:	93 e0       	ldi	r25, 0x03	; 3
    12fc:	09 95       	icall
  if (ADCD1.currentBufferPosition == bufferSize) {
    12fe:	80 91 75 03 	lds	r24, 0x0375	; 0x800375 <ADCD1+0x13>
    1302:	90 91 76 03 	lds	r25, 0x0376	; 0x800376 <ADCD1+0x14>
    1306:	c0 90 69 03 	lds	r12, 0x0369	; 0x800369 <ADCD1+0x7>
    130a:	d0 90 6a 03 	lds	r13, 0x036A	; 0x80036a <ADCD1+0x8>
    130e:	8e 15       	cp	r24, r14
    1310:	9f 05       	cpc	r25, r15
    1312:	09 f0       	breq	.+2      	; 0x1316 <__vector_21+0x1c4>
    1314:	7d cf       	rjmp	.-262    	; 0x1210 <__vector_21+0xbe>
    _adc_isr_full_code(&ADCD1);
    1316:	e0 91 69 03 	lds	r30, 0x0369	; 0x800369 <ADCD1+0x7>
    131a:	f0 91 6a 03 	lds	r31, 0x036A	; 0x80036a <ADCD1+0x8>
    131e:	80 81       	ld	r24, Z
    1320:	88 23       	and	r24, r24
    1322:	09 f4       	brne	.+2      	; 0x1326 <__vector_21+0x1d4>
    1324:	b4 cf       	rjmp	.-152    	; 0x128e <__vector_21+0x13c>
    1326:	23 81       	ldd	r18, Z+3	; 0x03
    1328:	34 81       	ldd	r19, Z+4	; 0x04
    132a:	21 15       	cp	r18, r1
    132c:	31 05       	cpc	r19, r1
    132e:	09 f4       	brne	.+2      	; 0x1332 <__vector_21+0x1e0>
    1330:	8a cf       	rjmp	.-236    	; 0x1246 <__vector_21+0xf4>
    1332:	40 91 67 03 	lds	r20, 0x0367	; 0x800367 <ADCD1+0x5>
    1336:	50 91 68 03 	lds	r21, 0x0368	; 0x800368 <ADCD1+0x6>
    133a:	60 91 65 03 	lds	r22, 0x0365	; 0x800365 <ADCD1+0x3>
    133e:	70 91 66 03 	lds	r23, 0x0366	; 0x800366 <ADCD1+0x4>
    1342:	42 30       	cpi	r20, 0x02	; 2
    1344:	51 05       	cpc	r21, r1
    1346:	e8 f0       	brcs	.+58     	; 0x1382 <__vector_21+0x230>
    1348:	56 95       	lsr	r21
    134a:	47 95       	ror	r20
    134c:	01 80       	ldd	r0, Z+1	; 0x01
    134e:	f2 81       	ldd	r31, Z+2	; 0x02
    1350:	e0 2d       	mov	r30, r0
    1352:	4e 9f       	mul	r20, r30
    1354:	c0 01       	movw	r24, r0
    1356:	4f 9f       	mul	r20, r31
    1358:	90 0d       	add	r25, r0
    135a:	5e 9f       	mul	r21, r30
    135c:	90 0d       	add	r25, r0
    135e:	11 24       	eor	r1, r1
    1360:	88 0f       	add	r24, r24
    1362:	99 1f       	adc	r25, r25
    1364:	68 0f       	add	r22, r24
    1366:	79 1f       	adc	r23, r25
    1368:	82 e6       	ldi	r24, 0x62	; 98
    136a:	93 e0       	ldi	r25, 0x03	; 3
    136c:	f9 01       	movw	r30, r18
    136e:	09 95       	icall
    1370:	6a cf       	rjmp	.-300    	; 0x1246 <__vector_21+0xf4>
    1372:	82 e0       	ldi	r24, 0x02	; 2
    1374:	80 93 62 03 	sts	0x0362, r24	; 0x800362 <ADCD1>
    1378:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <ADCD1+0x8>
    137c:	10 92 69 03 	sts	0x0369, r1	; 0x800369 <ADCD1+0x7>
    1380:	a4 cf       	rjmp	.-184    	; 0x12ca <__vector_21+0x178>
    1382:	82 e6       	ldi	r24, 0x62	; 98
    1384:	93 e0       	ldi	r25, 0x03	; 3
    1386:	f9 01       	movw	r30, r18
    1388:	09 95       	icall
    138a:	5d cf       	rjmp	.-326    	; 0x1246 <__vector_21+0xf4>
  if (ADCD1.currentBufferPosition == bufferSize) {
    138c:	2e 15       	cp	r18, r14
    138e:	3f 05       	cpc	r19, r15
    1390:	09 f0       	breq	.+2      	; 0x1394 <__vector_21+0x242>
    1392:	3e cf       	rjmp	.-388    	; 0x1210 <__vector_21+0xbe>
    1394:	58 cf       	rjmp	.-336    	; 0x1246 <__vector_21+0xf4>

00001396 <adc_lld_init>:
  adcObjectInit(&ADCD1);
    1396:	82 e6       	ldi	r24, 0x62	; 98
    1398:	93 e0       	ldi	r25, 0x03	; 3
    139a:	20 de       	rcall	.-960    	; 0xfdc <adcObjectInit>
  ADCSRA = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0) | (1 << ADIE);
    139c:	8f e0       	ldi	r24, 0x0F	; 15
    139e:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
  ADMUX = (0 << REFS1) | (0 << REFS0);
    13a2:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
}
    13a6:	08 95       	ret

000013a8 <adc_lld_start>:
  if (adcp->state == ADC_STOP) {
    13a8:	dc 01       	movw	r26, r24
    13aa:	2c 91       	ld	r18, X
    13ac:	21 30       	cpi	r18, 0x01	; 1
    13ae:	29 f4       	brne	.+10     	; 0x13ba <adc_lld_start+0x12>
    ADCSRA |= (1 << ADEN);
    13b0:	20 91 7a 00 	lds	r18, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
    13b4:	20 68       	ori	r18, 0x80	; 128
    13b6:	20 93 7a 00 	sts	0x007A, r18	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
  if (adcp->config != NULL) {
    13ba:	dc 01       	movw	r26, r24
    13bc:	11 96       	adiw	r26, 0x01	; 1
    13be:	ed 91       	ld	r30, X+
    13c0:	fc 91       	ld	r31, X
    13c2:	30 97       	sbiw	r30, 0x00	; 0
    13c4:	39 f0       	breq	.+14     	; 0x13d4 <adc_lld_start+0x2c>
    ADMUX = (adcp->config->analog_reference << REFS0);
    13c6:	80 81       	ld	r24, Z
    13c8:	82 95       	swap	r24
    13ca:	88 0f       	add	r24, r24
    13cc:	88 0f       	add	r24, r24
    13ce:	80 7c       	andi	r24, 0xC0	; 192
    13d0:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
}
    13d4:	08 95       	ret

000013d6 <adc_lld_start_conversion>:
  adcp->currentBufferPosition=0;
    13d6:	dc 01       	movw	r26, r24
    13d8:	54 96       	adiw	r26, 0x14	; 20
    13da:	1c 92       	st	X, r1
    13dc:	1e 92       	st	-X, r1
    13de:	53 97       	sbiw	r26, 0x13	; 19
  setAdcChannel(getAdcChannelNumberFromMask(adcp->grpp->channelsMask,0));
    13e0:	17 96       	adiw	r26, 0x07	; 7
    13e2:	ed 91       	ld	r30, X+
    13e4:	fc 91       	ld	r31, X
    13e6:	85 81       	ldd	r24, Z+5	; 0x05
  for (uint8_t i = 0; mask > 0; i++) {
    13e8:	88 23       	and	r24, r24
    13ea:	b1 f0       	breq	.+44     	; 0x1418 <adc_lld_start_conversion+0x42>
    if (mask & 0x01) {
    13ec:	90 e0       	ldi	r25, 0x00	; 0
    13ee:	80 fd       	sbrc	r24, 0
    13f0:	07 c0       	rjmp	.+14     	; 0x1400 <adc_lld_start_conversion+0x2a>
    mask >>= 1;
    13f2:	86 95       	lsr	r24
  for (uint8_t i = 0; mask > 0; i++) {
    13f4:	9f 5f       	subi	r25, 0xFF	; 255
    13f6:	88 23       	and	r24, r24
    13f8:	79 f0       	breq	.+30     	; 0x1418 <adc_lld_start_conversion+0x42>
    if (mask & 0x01) {
    13fa:	80 ff       	sbrs	r24, 0
    13fc:	fa cf       	rjmp	.-12     	; 0x13f2 <adc_lld_start_conversion+0x1c>
    13fe:	97 70       	andi	r25, 0x07	; 7
  ADMUX = (ADMUX & 0xf8) | (channelNum & 0x07);
    1400:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
    1404:	88 7f       	andi	r24, 0xF8	; 248
    1406:	89 2b       	or	r24, r25
    1408:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
  ADCSRA |= 1 << ADSC;
    140c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
    1410:	80 64       	ori	r24, 0x40	; 64
    1412:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
}
    1416:	08 95       	ret
  for (uint8_t i = 0; mask > 0; i++) {
    1418:	97 e0       	ldi	r25, 0x07	; 7
    141a:	f2 cf       	rjmp	.-28     	; 0x1400 <adc_lld_start_conversion+0x2a>

0000141c <_pal_lld_init>:
 *
 * @param[in] config    the AVR ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    141c:	fc 01       	movw	r30, r24
  PORTA = config->porta.out;
  DDRA = config->porta.dir;
#endif

#if defined(PORTB) || defined(__DOXYGEN__)
  PORTB = config->portb.out;
    141e:	80 81       	ld	r24, Z
    1420:	85 b9       	out	0x05, r24	; 5
  DDRB = config->portb.dir;
    1422:	81 81       	ldd	r24, Z+1	; 0x01
    1424:	84 b9       	out	0x04, r24	; 4
#endif

#if defined(PORTC) || defined(__DOXYGEN__)
  PORTC = config->portc.out;
    1426:	82 81       	ldd	r24, Z+2	; 0x02
    1428:	88 b9       	out	0x08, r24	; 8
  DDRC = config->portc.dir;
    142a:	83 81       	ldd	r24, Z+3	; 0x03
    142c:	87 b9       	out	0x07, r24	; 7
#endif

#if defined(PORTD) || defined(__DOXYGEN__)
  PORTD = config->portd.out;
    142e:	84 81       	ldd	r24, Z+4	; 0x04
    1430:	8b b9       	out	0x0b, r24	; 11
  DDRD = config->portd.dir;
    1432:	85 81       	ldd	r24, Z+5	; 0x05
    1434:	8a b9       	out	0x0a, r24	; 10

#if defined(PORTL) || defined(__DOXYGEN__)
  PORTL = config->portl.out;
  DDRL = config->portl.dir;
#endif
}
    1436:	08 95       	ret

00001438 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    1438:	fc 01       	movw	r30, r24

  switch (mode) {
    143a:	42 30       	cpi	r20, 0x02	; 2
    143c:	d1 f0       	breq	.+52     	; 0x1472 <_pal_lld_setgroupmode+0x3a>
    143e:	58 f0       	brcs	.+22     	; 0x1456 <_pal_lld_setgroupmode+0x1e>
    1440:	45 30       	cpi	r20, 0x05	; 5
    1442:	b9 f0       	breq	.+46     	; 0x1472 <_pal_lld_setgroupmode+0x3a>
    1444:	46 30       	cpi	r20, 0x06	; 6
    1446:	21 f4       	brne	.+8      	; 0x1450 <_pal_lld_setgroupmode+0x18>
  case PAL_MODE_INPUT_PULLUP:
    port->dir &= ~mask;
    port->out |= mask;
    break;
  case PAL_MODE_OUTPUT_PUSHPULL:
    port->dir |= mask;
    1448:	81 81       	ldd	r24, Z+1	; 0x01
    144a:	68 2b       	or	r22, r24
    144c:	61 83       	std	Z+1, r22	; 0x01
    break;
  }
}
    144e:	08 95       	ret
    1450:	43 30       	cpi	r20, 0x03	; 3
    1452:	29 f0       	breq	.+10     	; 0x145e <_pal_lld_setgroupmode+0x26>
    1454:	08 95       	ret
    1456:	44 23       	and	r20, r20
    1458:	61 f0       	breq	.+24     	; 0x1472 <_pal_lld_setgroupmode+0x3a>
    145a:	41 30       	cpi	r20, 0x01	; 1
    145c:	49 f4       	brne	.+18     	; 0x1470 <_pal_lld_setgroupmode+0x38>
    port->dir &= ~mask;
    145e:	91 81       	ldd	r25, Z+1	; 0x01
    1460:	86 2f       	mov	r24, r22
    1462:	80 95       	com	r24
    1464:	89 23       	and	r24, r25
    1466:	81 83       	std	Z+1, r24	; 0x01
    port->out |= mask;
    1468:	82 81       	ldd	r24, Z+2	; 0x02
    146a:	68 2b       	or	r22, r24
    146c:	62 83       	std	Z+2, r22	; 0x02
    break;
    146e:	08 95       	ret
    1470:	08 95       	ret
    port->dir &= ~mask;
    1472:	81 81       	ldd	r24, Z+1	; 0x01
    1474:	60 95       	com	r22
    1476:	86 23       	and	r24, r22
    1478:	81 83       	std	Z+1, r24	; 0x01
    port->out &= ~mask;
    147a:	82 81       	ldd	r24, Z+2	; 0x02
    147c:	68 23       	and	r22, r24
    147e:	62 83       	std	Z+2, r22	; 0x02
    break;
    1480:	08 95       	ret

00001482 <__vector_11>:
#if (OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING) || defined(__DOXYGEN__)

/**
 * @brief Timer handler for free running mode.
 */
OSAL_IRQ_HANDLER(TIMER1_COMPA_vect) {
    1482:	1f 92       	push	r1
    1484:	0f 92       	push	r0
    1486:	0f b6       	in	r0, 0x3f	; 63
    1488:	0f 92       	push	r0
    148a:	11 24       	eor	r1, r1
    148c:	2f 93       	push	r18
    148e:	3f 93       	push	r19
    1490:	4f 93       	push	r20
    1492:	5f 93       	push	r21
    1494:	6f 93       	push	r22
    1496:	7f 93       	push	r23
    1498:	8f 93       	push	r24
    149a:	9f 93       	push	r25
    149c:	af 93       	push	r26
    149e:	bf 93       	push	r27
    14a0:	ef 93       	push	r30
    14a2:	ff 93       	push	r31

  OSAL_IRQ_PROLOGUE();
    14a4:	81 e0       	ldi	r24, 0x01	; 1
    14a6:	80 93 61 03 	sts	0x0361, r24	; 0x800361 <__avr_in_isr>
  chSysTimerHandlerI();
    14aa:	0e 94 7b 00 	call	0xf6	; 0xf6 <chSysTimerHandlerI>

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
    14ae:	10 92 61 03 	sts	0x0361, r1	; 0x800361 <__avr_in_isr>
    14b2:	c9 d8       	rcall	.-3694   	; 0x646 <chSchIsPreemptionRequired>
    14b4:	81 11       	cpse	r24, r1
    14b6:	11 c0       	rjmp	.+34     	; 0x14da <__vector_11+0x58>
}
    14b8:	ff 91       	pop	r31
    14ba:	ef 91       	pop	r30
    14bc:	bf 91       	pop	r27
    14be:	af 91       	pop	r26
    14c0:	9f 91       	pop	r25
    14c2:	8f 91       	pop	r24
    14c4:	7f 91       	pop	r23
    14c6:	6f 91       	pop	r22
    14c8:	5f 91       	pop	r21
    14ca:	4f 91       	pop	r20
    14cc:	3f 91       	pop	r19
    14ce:	2f 91       	pop	r18
    14d0:	0f 90       	pop	r0
    14d2:	0f be       	out	0x3f, r0	; 63
    14d4:	0f 90       	pop	r0
    14d6:	1f 90       	pop	r1
  OSAL_IRQ_EPILOGUE();
    14d8:	18 95       	reti
    14da:	02 d9       	rcall	.-3580   	; 0x6e0 <chSchDoReschedule>
}
    14dc:	ed cf       	rjmp	.-38     	; 0x14b8 <__vector_11+0x36>

000014de <st_lld_init>:
  /*
   * Periodic mode uses Timer 1 (16 bit).
   */

  /* CTC mode, no clock source. */
  TCCR1A     = 0;
    14de:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
  TCCR1B     = _BV(WGM12);
    14e2:	e1 e8       	ldi	r30, 0x81	; 129
    14e4:	f0 e0       	ldi	r31, 0x00	; 0
    14e6:	88 e0       	ldi	r24, 0x08	; 8
    14e8:	80 83       	st	Z, r24

  /* start disabled. */
  TCCR1C     = 0;
    14ea:	10 92 82 00 	sts	0x0082, r1	; 0x800082 <__TEXT_REGION_LENGTH__+0x7e0082>
  OCR1A      = 0;
    14ee:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    14f2:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
  TCNT1      = 0;
    14f6:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    14fa:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
  TIFR_REG   = _BV(OCF1A);                              /* Reset pending.   */    
    14fe:	82 e0       	ldi	r24, 0x02	; 2
    1500:	86 bb       	out	0x16, r24	; 22
  TIMSK_REG  = 0;
    1502:	10 92 6f 00 	sts	0x006F, r1	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
  TCCR1B     = PRESCALER;
    1506:	85 e0       	ldi	r24, 0x05	; 5
    1508:	80 83       	st	Z, r24
#else
  #error "Neither TCCR0A nor TCCR0 registers are defined"
#endif

#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    150a:	08 95       	ret

0000150c <notify1>:

#if AVR_SERIAL_USE_USART0 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  UCSR0B |= (1 << UDRIE0);
    150c:	e1 ec       	ldi	r30, 0xC1	; 193
    150e:	f0 e0       	ldi	r31, 0x00	; 0
    1510:	80 81       	ld	r24, Z
    1512:	80 62       	ori	r24, 0x20	; 32
    1514:	80 83       	st	Z, r24
}
    1516:	08 95       	ret

00001518 <__vector_18>:
/**
 * @brief   USART0 RX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_RX_VECT) {
    1518:	1f 92       	push	r1
    151a:	0f 92       	push	r0
    151c:	0f b6       	in	r0, 0x3f	; 63
    151e:	0f 92       	push	r0
    1520:	11 24       	eor	r1, r1
    1522:	2f 93       	push	r18
    1524:	3f 93       	push	r19
    1526:	4f 93       	push	r20
    1528:	5f 93       	push	r21
    152a:	6f 93       	push	r22
    152c:	7f 93       	push	r23
    152e:	8f 93       	push	r24
    1530:	9f 93       	push	r25
    1532:	af 93       	push	r26
    1534:	bf 93       	push	r27
    1536:	ef 93       	push	r30
    1538:	ff 93       	push	r31
  uint8_t sra;

  OSAL_IRQ_PROLOGUE();
    153a:	81 e0       	ldi	r24, 0x01	; 1
    153c:	80 93 61 03 	sts	0x0361, r24	; 0x800361 <__avr_in_isr>

  sra = UCSR0A;
    1540:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
  if (sra & ((1 << DOR0) | (1 << UPE0) | (1 << FE0)))
    1544:	98 2f       	mov	r25, r24
    1546:	9c 71       	andi	r25, 0x1C	; 28
    1548:	d9 f4       	brne	.+54     	; 0x1580 <__vector_18+0x68>
    set_error(sra, &SD1);
  osalSysLockFromISR();
  sdIncomingDataI(&SD1, UDR0);
    154a:	60 91 c6 00 	lds	r22, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    154e:	87 e7       	ldi	r24, 0x77	; 119
    1550:	93 e0       	ldi	r25, 0x03	; 3
    1552:	c0 dd       	rcall	.-1152   	; 0x10d4 <sdIncomingDataI>
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
    1554:	10 92 61 03 	sts	0x0361, r1	; 0x800361 <__avr_in_isr>
    1558:	76 d8       	rcall	.-3860   	; 0x646 <chSchIsPreemptionRequired>
    155a:	81 11       	cpse	r24, r1
    155c:	1c c0       	rjmp	.+56     	; 0x1596 <__vector_18+0x7e>
}
    155e:	ff 91       	pop	r31
    1560:	ef 91       	pop	r30
    1562:	bf 91       	pop	r27
    1564:	af 91       	pop	r26
    1566:	9f 91       	pop	r25
    1568:	8f 91       	pop	r24
    156a:	7f 91       	pop	r23
    156c:	6f 91       	pop	r22
    156e:	5f 91       	pop	r21
    1570:	4f 91       	pop	r20
    1572:	3f 91       	pop	r19
    1574:	2f 91       	pop	r18
    1576:	0f 90       	pop	r0
    1578:	0f be       	out	0x3f, r0	; 63
    157a:	0f 90       	pop	r0
    157c:	1f 90       	pop	r1
    157e:	18 95       	reti
    sts |= SD_OVERRUN_ERROR;
    1580:	60 e8       	ldi	r22, 0x80	; 128
  if (sra & dor)
    1582:	83 ff       	sbrs	r24, 3
  eventflags_t sts = 0;
    1584:	60 e0       	ldi	r22, 0x00	; 0
  if (sra & upe)
    1586:	82 fd       	sbrc	r24, 2
    sts |= SD_PARITY_ERROR;
    1588:	60 62       	ori	r22, 0x20	; 32
  if (sra & fe)
    158a:	84 fd       	sbrc	r24, 4
    sts |= SD_FRAMING_ERROR;
    158c:	60 64       	ori	r22, 0x40	; 64
  chEvtBroadcastFlagsI(esp, flags);
    158e:	89 e7       	ldi	r24, 0x79	; 121
    1590:	93 e0       	ldi	r25, 0x03	; 3
}
    1592:	19 da       	rcall	.-3022   	; 0x9c6 <chEvtBroadcastFlagsI>
  OSAL_IRQ_EPILOGUE();
    1594:	da cf       	rjmp	.-76     	; 0x154a <__vector_18+0x32>
    1596:	a4 d8       	rcall	.-3768   	; 0x6e0 <chSchDoReschedule>
}
    1598:	e2 cf       	rjmp	.-60     	; 0x155e <__vector_18+0x46>

0000159a <__vector_19>:
/**
 * @brief   USART0 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(AVR_SD1_TX_VECT) {
    159a:	1f 92       	push	r1
    159c:	0f 92       	push	r0
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	0f 92       	push	r0
    15a2:	11 24       	eor	r1, r1
    15a4:	2f 93       	push	r18
    15a6:	3f 93       	push	r19
    15a8:	4f 93       	push	r20
    15aa:	5f 93       	push	r21
    15ac:	6f 93       	push	r22
    15ae:	7f 93       	push	r23
    15b0:	8f 93       	push	r24
    15b2:	9f 93       	push	r25
    15b4:	af 93       	push	r26
    15b6:	bf 93       	push	r27
    15b8:	ef 93       	push	r30
    15ba:	ff 93       	push	r31
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    15bc:	81 e0       	ldi	r24, 0x01	; 1
    15be:	80 93 61 03 	sts	0x0361, r24	; 0x800361 <__avr_in_isr>

  osalSysLockFromISR();
  b = sdRequestDataI(&SD1);
    15c2:	87 e7       	ldi	r24, 0x77	; 119
    15c4:	93 e0       	ldi	r25, 0x03	; 3
    15c6:	aa dd       	rcall	.-1196   	; 0x111c <sdRequestDataI>
  osalSysUnlockFromISR();
  if (b < MSG_OK)
    15c8:	97 fd       	sbrc	r25, 7
    15ca:	18 c0       	rjmp	.+48     	; 0x15fc <__vector_19+0x62>
    UCSR0B &= ~(1 << UDRIE0);
  else
    UDR0 = b;
    15cc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

  OSAL_IRQ_EPILOGUE();
    15d0:	10 92 61 03 	sts	0x0361, r1	; 0x800361 <__avr_in_isr>
    15d4:	38 d8       	rcall	.-3984   	; 0x646 <chSchIsPreemptionRequired>
    15d6:	81 11       	cpse	r24, r1
    15d8:	1b c0       	rjmp	.+54     	; 0x1610 <__vector_19+0x76>
}
    15da:	ff 91       	pop	r31
    15dc:	ef 91       	pop	r30
    15de:	bf 91       	pop	r27
    15e0:	af 91       	pop	r26
    15e2:	9f 91       	pop	r25
    15e4:	8f 91       	pop	r24
    15e6:	7f 91       	pop	r23
    15e8:	6f 91       	pop	r22
    15ea:	5f 91       	pop	r21
    15ec:	4f 91       	pop	r20
    15ee:	3f 91       	pop	r19
    15f0:	2f 91       	pop	r18
    15f2:	0f 90       	pop	r0
    15f4:	0f be       	out	0x3f, r0	; 63
    15f6:	0f 90       	pop	r0
    15f8:	1f 90       	pop	r1
    15fa:	18 95       	reti
    UCSR0B &= ~(1 << UDRIE0);
    15fc:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1600:	8f 7d       	andi	r24, 0xDF	; 223
    1602:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
  OSAL_IRQ_EPILOGUE();
    1606:	10 92 61 03 	sts	0x0361, r1	; 0x800361 <__avr_in_isr>
    160a:	1d d8       	rcall	.-4038   	; 0x646 <chSchIsPreemptionRequired>
    160c:	88 23       	and	r24, r24
    160e:	29 f3       	breq	.-54     	; 0x15da <__vector_19+0x40>
    1610:	67 d8       	rcall	.-3890   	; 0x6e0 <chSchDoReschedule>
}
    1612:	e3 cf       	rjmp	.-58     	; 0x15da <__vector_19+0x40>

00001614 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if AVR_SERIAL_USE_USART0
  sdObjectInit(&SD1, NULL, notify1);
    1614:	46 e8       	ldi	r20, 0x86	; 134
    1616:	5a e0       	ldi	r21, 0x0A	; 10
    1618:	70 e0       	ldi	r23, 0x00	; 0
    161a:	60 e0       	ldi	r22, 0x00	; 0
    161c:	87 e7       	ldi	r24, 0x77	; 119
    161e:	93 e0       	ldi	r25, 0x03	; 3
    1620:	23 cd       	rjmp	.-1466   	; 0x1068 <sdObjectInit>

00001622 <sd_lld_start>:
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    1622:	61 15       	cp	r22, r1
    1624:	71 05       	cpc	r23, r1
    1626:	21 f0       	breq	.+8      	; 0x1630 <sd_lld_start+0xe>
    config = &default_config;

#if AVR_SERIAL_USE_USART0
  if (&SD1 == sdp) {
    1628:	87 57       	subi	r24, 0x77	; 119
    162a:	93 40       	sbci	r25, 0x03	; 3
    162c:	99 f0       	breq	.+38     	; 0x1654 <sd_lld_start+0x32>
  if (&SD2 == sdp) {
    usart1_init(config);
    return;
  }
#endif
}
    162e:	08 95       	ret
  if (&SD1 == sdp) {
    1630:	87 57       	subi	r24, 0x77	; 119
    1632:	93 40       	sbci	r25, 0x03	; 3
    1634:	e1 f7       	brne	.-8      	; 0x162e <sd_lld_start+0xc>
  UBRR0L = config->sc_brr;
    1636:	80 e1       	ldi	r24, 0x10	; 16
    1638:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
    163c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
  UCSR0A = (1 << U2X0);
    1640:	82 e0       	ldi	r24, 0x02	; 2
    1642:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    1646:	88 e9       	ldi	r24, 0x98	; 152
    1648:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
    164c:	86 e0       	ldi	r24, 0x06	; 6
  UCSR0C = ucsr0c;
    164e:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    1652:	08 95       	ret
  UBRR0L = config->sc_brr;
    1654:	fb 01       	movw	r30, r22
    1656:	80 81       	ld	r24, Z
    1658:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
  UBRR0H = (config->sc_brr >> 8) & 0x0f;
    165c:	81 81       	ldd	r24, Z+1	; 0x01
    165e:	8f 70       	andi	r24, 0x0F	; 15
    1660:	80 93 c5 00 	sts	0x00C5, r24	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
  UCSR0A = (1 << U2X0);
    1664:	82 e0       	ldi	r24, 0x02	; 2
    1666:	80 93 c0 00 	sts	0x00C0, r24	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
  UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);
    166a:	88 e9       	ldi	r24, 0x98	; 152
    166c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
  switch (config->sc_bits_per_char) {
    1670:	82 81       	ldd	r24, Z+2	; 0x02
    1672:	81 30       	cpi	r24, 0x01	; 1
    1674:	89 f0       	breq	.+34     	; 0x1698 <sd_lld_start+0x76>
    1676:	88 23       	and	r24, r24
    1678:	69 f0       	breq	.+26     	; 0x1694 <sd_lld_start+0x72>
    167a:	82 30       	cpi	r24, 0x02	; 2
    167c:	49 f0       	breq	.+18     	; 0x1690 <sd_lld_start+0x6e>
    167e:	84 30       	cpi	r24, 0x04	; 4
    1680:	69 f4       	brne	.+26     	; 0x169c <sd_lld_start+0x7a>
    UCSR0B |= (1 << UCSZ02);
    1682:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    1686:	84 60       	ori	r24, 0x04	; 4
    1688:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
    168c:	86 e0       	ldi	r24, 0x06	; 6
    168e:	df cf       	rjmp	.-66     	; 0x164e <sd_lld_start+0x2c>
    ucsr0c = (1 << UCSZ01);
    1690:	84 e0       	ldi	r24, 0x04	; 4
    1692:	dd cf       	rjmp	.-70     	; 0x164e <sd_lld_start+0x2c>
    ucsr0c = 0;
    1694:	80 e0       	ldi	r24, 0x00	; 0
    1696:	db cf       	rjmp	.-74     	; 0x164e <sd_lld_start+0x2c>
    ucsr0c = (1 << UCSZ00);
    1698:	82 e0       	ldi	r24, 0x02	; 2
    169a:	d9 cf       	rjmp	.-78     	; 0x164e <sd_lld_start+0x2c>
    ucsr0c = (1 << UCSZ00) | (1 << UCSZ01);
    169c:	86 e0       	ldi	r24, 0x06	; 6
    169e:	d7 cf       	rjmp	.-82     	; 0x164e <sd_lld_start+0x2c>

000016a0 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  EICRA  = 0x00;
    16a0:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__TEXT_REGION_LENGTH__+0x7e0069>
  EIMSK  = 0x00;
    16a4:	1d ba       	out	0x1d, r1	; 29

}
    16a6:	08 95       	ret

000016a8 <adc_cb>:
void serial_write(char *data) {
  chnWriteTimeout(&SD1, (const uint8_t *)data, strlen(data), TIME_INFINITE);
}

void adc_cb(ADCDriver *adcp, adcsample_t *buffer, size_t n){
  flag = 1;
    16a8:	81 e0       	ldi	r24, 0x01	; 1
    16aa:	80 93 c1 03 	sts	0x03C1, r24	; 0x8003c1 <flag>
}
    16ae:	08 95       	ret

000016b0 <serial_write>:
  chnWriteTimeout(&SD1, (const uint8_t *)data, strlen(data), TIME_INFINITE);
    16b0:	fc 01       	movw	r30, r24
    16b2:	01 90       	ld	r0, Z+
    16b4:	00 20       	and	r0, r0
    16b6:	e9 f7       	brne	.-6      	; 0x16b2 <serial_write+0x2>
    16b8:	31 97       	sbiw	r30, 0x01	; 1
    16ba:	af 01       	movw	r20, r30
    16bc:	48 1b       	sub	r20, r24
    16be:	59 0b       	sbc	r21, r25
    16c0:	e0 91 77 03 	lds	r30, 0x0377	; 0x800377 <SD1>
    16c4:	f0 91 78 03 	lds	r31, 0x0378	; 0x800378 <SD1+0x1>
    16c8:	06 84       	ldd	r0, Z+14	; 0x0e
    16ca:	f7 85       	ldd	r31, Z+15	; 0x0f
    16cc:	e0 2d       	mov	r30, r0
    16ce:	2f ef       	ldi	r18, 0xFF	; 255
    16d0:	3f ef       	ldi	r19, 0xFF	; 255
    16d2:	bc 01       	movw	r22, r24
    16d4:	87 e7       	ldi	r24, 0x77	; 119
    16d6:	93 e0       	ldi	r25, 0x03	; 3
    16d8:	09 94       	ijmp

000016da <Thread1>:
static THD_FUNCTION(Thread1, arg) {
    16da:	cf 93       	push	r28
    16dc:	df 93       	push	r29
    16de:	cd b7       	in	r28, 0x3d	; 61
    16e0:	de b7       	in	r29, 0x3e	; 62
    16e2:	c8 5c       	subi	r28, 0xC8	; 200
    16e4:	d1 09       	sbc	r29, r1
    16e6:	0f b6       	in	r0, 0x3f	; 63
    16e8:	f8 94       	cli
    16ea:	de bf       	out	0x3e, r29	; 62
    16ec:	0f be       	out	0x3f, r0	; 63
    16ee:	cd bf       	out	0x3d, r28	; 61
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
    16f0:	e0 91 35 03 	lds	r30, 0x0335	; 0x800335 <ch+0xb>
    16f4:	f0 91 36 03 	lds	r31, 0x0336	; 0x800336 <ch+0xc>
    16f8:	8d e4       	ldi	r24, 0x4D	; 77
    16fa:	91 e0       	ldi	r25, 0x01	; 1
    16fc:	94 87       	std	Z+12, r25	; 0x0c
    16fe:	83 87       	std	Z+11, r24	; 0x0b
    1700:	8e 01       	movw	r16, r28
    1702:	0f 5f       	subi	r16, 0xFF	; 255
    1704:	1f 4f       	sbci	r17, 0xFF	; 255
    1706:	19 c0       	rjmp	.+50     	; 0x173a <Thread1+0x60>
    palReadPad(IOPORT4, RAIN_PORT) == PAL_HIGH ? serial_write("High!\r\n") : serial_write("Low!\r\n");
    1708:	88 e6       	ldi	r24, 0x68	; 104
    170a:	91 e0       	ldi	r25, 0x01	; 1
    170c:	d1 df       	rcall	.-94     	; 0x16b0 <serial_write>
    chnWrite(&SD1, (const uint8_t *)buffer, strlen(buffer));
    170e:	f8 01       	movw	r30, r16
    1710:	01 90       	ld	r0, Z+
    1712:	00 20       	and	r0, r0
    1714:	e9 f7       	brne	.-6      	; 0x1710 <Thread1+0x36>
    1716:	31 97       	sbiw	r30, 0x01	; 1
    1718:	af 01       	movw	r20, r30
    171a:	40 1b       	sub	r20, r16
    171c:	51 0b       	sbc	r21, r17
    171e:	e0 91 77 03 	lds	r30, 0x0377	; 0x800377 <SD1>
    1722:	f0 91 78 03 	lds	r31, 0x0378	; 0x800378 <SD1+0x1>
    1726:	02 80       	ldd	r0, Z+2	; 0x02
    1728:	f3 81       	ldd	r31, Z+3	; 0x03
    172a:	e0 2d       	mov	r30, r0
    172c:	b8 01       	movw	r22, r16
    172e:	87 e7       	ldi	r24, 0x77	; 119
    1730:	93 e0       	ldi	r25, 0x03	; 3
    1732:	09 95       	icall
    chThdSleepMilliseconds(1000);
    1734:	88 e0       	ldi	r24, 0x08	; 8
    1736:	9d e3       	ldi	r25, 0x3D	; 61
    1738:	df d8       	rcall	.-3650   	; 0x8f8 <chThdSleep>
    palReadPad(IOPORT4, RAIN_PORT) == PAL_HIGH ? serial_write("High!\r\n") : serial_write("Low!\r\n");
    173a:	4a 99       	sbic	0x09, 2	; 9
    173c:	e5 cf       	rjmp	.-54     	; 0x1708 <Thread1+0x2e>
    173e:	80 e7       	ldi	r24, 0x70	; 112
    1740:	91 e0       	ldi	r25, 0x01	; 1
    1742:	b6 df       	rcall	.-148    	; 0x16b0 <serial_write>
    1744:	e4 cf       	rjmp	.-56     	; 0x170e <Thread1+0x34>

00001746 <initPorts>:

void initPorts() {

  /* Initialize input ports */
  palSetPadMode(IOPORT4, RAIN_PORT, PAL_MODE_INPUT);
    1746:	42 e0       	ldi	r20, 0x02	; 2
    1748:	64 e0       	ldi	r22, 0x04	; 4
    174a:	89 e2       	ldi	r24, 0x29	; 41
    174c:	90 e0       	ldi	r25, 0x00	; 0
    174e:	74 de       	rcall	.-792    	; 0x1438 <_pal_lld_setgroupmode>
  palSetPadMode(IOPORT4, DOOR_PORT, PAL_MODE_INPUT);
    1750:	42 e0       	ldi	r20, 0x02	; 2
    1752:	68 e0       	ldi	r22, 0x08	; 8
    1754:	89 e2       	ldi	r24, 0x29	; 41
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	6f de       	rcall	.-802    	; 0x1438 <_pal_lld_setgroupmode>
  /* Initialize output ports */
  palSetPadMode(IOPORT4, BUZZER_PORT, PAL_MODE_OUTPUT_PUSHPULL); //open drain?
    175a:	46 e0       	ldi	r20, 0x06	; 6
    175c:	60 e1       	ldi	r22, 0x10	; 16
    175e:	89 e2       	ldi	r24, 0x29	; 41
    1760:	90 e0       	ldi	r25, 0x00	; 0
    1762:	6a de       	rcall	.-812    	; 0x1438 <_pal_lld_setgroupmode>
  palSetPadMode(IOPORT2, MOTOR_PORT, PAL_MODE_OUTPUT_PUSHPULL); //open drain?
    1764:	46 e0       	ldi	r20, 0x06	; 6
    1766:	62 e0       	ldi	r22, 0x02	; 2
    1768:	83 e2       	ldi	r24, 0x23	; 35
    176a:	90 e0       	ldi	r25, 0x00	; 0
    176c:	65 ce       	rjmp	.-822    	; 0x1438 <_pal_lld_setgroupmode>

0000176e <main>:
}

/*
 * Application entry point.
 */
int main(void) {
    176e:	cd b7       	in	r28, 0x3d	; 61
    1770:	de b7       	in	r29, 0x3e	; 62
    1772:	61 97       	sbiw	r28, 0x11	; 17
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	de bf       	out	0x3e, r29	; 62
    177a:	0f be       	out	0x3f, r0	; 63
    177c:	cd bf       	out	0x3d, r28	; 61
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
    177e:	c9 d9       	rcall	.-3182   	; 0xb12 <halInit>
  chSysInit();
    1780:	0e 94 64 00 	call	0xc8	; 0xc8 <chSysInit>
  initPorts();
    1784:	e0 df       	rcall	.-64     	; 0x1746 <initPorts>
  /*
   * Activates the serial driver 1 using the driver default configuration.
   */
  sdStart(&SD1, NULL);
    1786:	70 e0       	ldi	r23, 0x00	; 0
    1788:	60 e0       	ldi	r22, 0x00	; 0
    178a:	87 e7       	ldi	r24, 0x77	; 119
    178c:	93 e0       	ldi	r25, 0x03	; 3
    178e:	97 dc       	rcall	.-1746   	; 0x10be <sdStart>

  serial_write(" Starting Guardian Angel...\r\n");
    1790:	87 e7       	ldi	r24, 0x77	; 119
    1792:	91 e0       	ldi	r25, 0x01	; 1
    1794:	8d df       	rcall	.-230    	; 0x16b0 <serial_write>
    1796:	81 e0       	ldi	r24, 0x01	; 1

  /* ADC configuration */
  ADCConfig cfg = {ANALOG_REFERENCE_AVCC};
    1798:	89 8b       	std	Y+17, r24	; 0x11
    179a:	86 e0       	ldi	r24, 0x06	; 6
  ADCConversionGroup group = {0, NBR_CHANNELS, adc_cb, 0x7};
    179c:	e0 e0       	ldi	r30, 0x00	; 0
    179e:	f1 e0       	ldi	r31, 0x01	; 1
    17a0:	de 01       	movw	r26, r28
    17a2:	1b 96       	adiw	r26, 0x0b	; 11
    17a4:	01 90       	ld	r0, Z+
    17a6:	0d 92       	st	X+, r0
    17a8:	8a 95       	dec	r24
    17aa:	e1 f7       	brne	.-8      	; 0x17a4 <main+0x36>
    17ac:	be 01       	movw	r22, r28
  adcsample_t buffer[DEPTH*NBR_CHANNELS];
  adcStart(&ADCD1, &cfg);
    17ae:	6f 5e       	subi	r22, 0xEF	; 239
    17b0:	7f 4f       	sbci	r23, 0xFF	; 255
    17b2:	82 e6       	ldi	r24, 0x62	; 98
    17b4:	93 e0       	ldi	r25, 0x03	; 3
    17b6:	22 dc       	rcall	.-1980   	; 0xffc <adcStart>
    17b8:	10 e0       	ldi	r17, 0x00	; 0

  /*
   * Starts the reading sensors thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
    17ba:	00 e0       	ldi	r16, 0x00	; 0
    17bc:	2d e6       	ldi	r18, 0x6D	; 109
    17be:	3b e0       	ldi	r19, 0x0B	; 11
    17c0:	40 e8       	ldi	r20, 0x80	; 128
    17c2:	61 e8       	ldi	r22, 0x81	; 129
    17c4:	70 e0       	ldi	r23, 0x00	; 0
    17c6:	80 e4       	ldi	r24, 0x40	; 64
    17c8:	92 e0       	ldi	r25, 0x02	; 2
    17ca:	1e d8       	rcall	.-4036   	; 0x808 <chThdCreateStatic>
    17cc:	11 e0       	ldi	r17, 0x01	; 1


  while(TRUE) {
    adcStartConversion(&ADCD1, &group, buffer, DEPTH);
    states state = bus_stopped; // state default
    doorOpened = true;
    17ce:	25 e0       	ldi	r18, 0x05	; 5
    adcStartConversion(&ADCD1, &group, buffer, DEPTH);
    17d0:	30 e0       	ldi	r19, 0x00	; 0
    17d2:	ae 01       	movw	r20, r28
    17d4:	4f 5f       	subi	r20, 0xFF	; 255
    17d6:	5f 4f       	sbci	r21, 0xFF	; 255
    17d8:	be 01       	movw	r22, r28
    17da:	65 5f       	subi	r22, 0xF5	; 245
    17dc:	7f 4f       	sbci	r23, 0xFF	; 255
    17de:	82 e6       	ldi	r24, 0x62	; 98
    17e0:	93 e0       	ldi	r25, 0x03	; 3
    17e2:	19 dc       	rcall	.-1998   	; 0x1016 <adcStartConversion>
    doorOpened = true;
    17e4:	10 93 c0 03 	sts	0x03C0, r17	; 0x8003c0 <doorOpened>
    
      // State Machine
      switch(state){
        case bus_stopped:
          if (doorOpened){
             serial_write("Bus Stopped - Door is Open\r\n");
    17e8:	85 e9       	ldi	r24, 0x95	; 149
    17ea:	91 e0       	ldi	r25, 0x01	; 1
    17ec:	61 df       	rcall	.-318    	; 0x16b0 <serial_write>
    17ee:	ef cf       	rjmp	.-34     	; 0x17ce <main+0x60>

000017f0 <vfprintf>:
    17f0:	ab e0       	ldi	r26, 0x0B	; 11
    17f2:	b0 e0       	ldi	r27, 0x00	; 0
    17f4:	ed ef       	ldi	r30, 0xFD	; 253
    17f6:	fb e0       	ldi	r31, 0x0B	; 11
    17f8:	bc c2       	rjmp	.+1400   	; 0x1d72 <__prologue_saves__+0x8>
    17fa:	5c 01       	movw	r10, r24
    17fc:	6b 01       	movw	r12, r22
    17fe:	3a 01       	movw	r6, r20
    1800:	fc 01       	movw	r30, r24
    1802:	17 82       	std	Z+7, r1	; 0x07
    1804:	16 82       	std	Z+6, r1	; 0x06
    1806:	83 81       	ldd	r24, Z+3	; 0x03
    1808:	81 ff       	sbrs	r24, 1
    180a:	eb c0       	rjmp	.+470    	; 0x19e2 <vfprintf+0x1f2>
    180c:	ce 01       	movw	r24, r28
    180e:	01 96       	adiw	r24, 0x01	; 1
    1810:	4c 01       	movw	r8, r24
    1812:	f5 01       	movw	r30, r10
    1814:	f3 80       	ldd	r15, Z+3	; 0x03
    1816:	f6 01       	movw	r30, r12
    1818:	f3 fc       	sbrc	r15, 3
    181a:	15 91       	lpm	r17, Z+
    181c:	f3 fe       	sbrs	r15, 3
    181e:	11 91       	ld	r17, Z+
    1820:	6f 01       	movw	r12, r30
    1822:	11 23       	and	r17, r17
    1824:	09 f4       	brne	.+2      	; 0x1828 <vfprintf+0x38>
    1826:	34 c0       	rjmp	.+104    	; 0x1890 <vfprintf+0xa0>
    1828:	15 32       	cpi	r17, 0x25	; 37
    182a:	39 f4       	brne	.+14     	; 0x183a <vfprintf+0x4a>
    182c:	f3 fc       	sbrc	r15, 3
    182e:	15 91       	lpm	r17, Z+
    1830:	f3 fe       	sbrs	r15, 3
    1832:	11 91       	ld	r17, Z+
    1834:	6f 01       	movw	r12, r30
    1836:	15 32       	cpi	r17, 0x25	; 37
    1838:	99 f5       	brne	.+102    	; 0x18a0 <vfprintf+0xb0>
    183a:	b5 01       	movw	r22, r10
    183c:	81 2f       	mov	r24, r17
    183e:	90 e0       	ldi	r25, 0x00	; 0
    1840:	21 d3       	rcall	.+1602   	; 0x1e84 <fputc>
    1842:	e7 cf       	rjmp	.-50     	; 0x1812 <vfprintf+0x22>
    1844:	11 23       	and	r17, r17
    1846:	21 f1       	breq	.+72     	; 0x1890 <vfprintf+0xa0>
    1848:	61 2f       	mov	r22, r17
    184a:	70 e0       	ldi	r23, 0x00	; 0
    184c:	8f e6       	ldi	r24, 0x6F	; 111
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	cb d2       	rcall	.+1430   	; 0x1de8 <strchr_P>
    1852:	89 2b       	or	r24, r25
    1854:	99 f4       	brne	.+38     	; 0x187c <vfprintf+0x8c>
    1856:	13 32       	cpi	r17, 0x23	; 35
    1858:	09 f1       	breq	.+66     	; 0x189c <vfprintf+0xac>
    185a:	1c 36       	cpi	r17, 0x6C	; 108
    185c:	71 f0       	breq	.+28     	; 0x187a <vfprintf+0x8a>
    185e:	61 2f       	mov	r22, r17
    1860:	70 e0       	ldi	r23, 0x00	; 0
    1862:	88 e6       	ldi	r24, 0x68	; 104
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	c0 d2       	rcall	.+1408   	; 0x1de8 <strchr_P>
    1868:	89 2b       	or	r24, r25
    186a:	e1 f0       	breq	.+56     	; 0x18a4 <vfprintf+0xb4>
    186c:	f4 e0       	ldi	r31, 0x04	; 4
    186e:	6f 0e       	add	r6, r31
    1870:	71 1c       	adc	r7, r1
    1872:	b5 01       	movw	r22, r10
    1874:	8f e3       	ldi	r24, 0x3F	; 63
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	e3 cf       	rjmp	.-58     	; 0x1840 <vfprintf+0x50>
    187a:	00 68       	ori	r16, 0x80	; 128
    187c:	f6 01       	movw	r30, r12
    187e:	f3 fc       	sbrc	r15, 3
    1880:	15 91       	lpm	r17, Z+
    1882:	f3 fe       	sbrs	r15, 3
    1884:	11 91       	ld	r17, Z+
    1886:	6f 01       	movw	r12, r30
    1888:	07 ff       	sbrs	r16, 7
    188a:	dc cf       	rjmp	.-72     	; 0x1844 <vfprintf+0x54>
    188c:	11 11       	cpse	r17, r1
    188e:	e7 cf       	rjmp	.-50     	; 0x185e <vfprintf+0x6e>
    1890:	f5 01       	movw	r30, r10
    1892:	86 81       	ldd	r24, Z+6	; 0x06
    1894:	97 81       	ldd	r25, Z+7	; 0x07
    1896:	2b 96       	adiw	r28, 0x0b	; 11
    1898:	ee e0       	ldi	r30, 0x0E	; 14
    189a:	87 c2       	rjmp	.+1294   	; 0x1daa <__epilogue_restores__+0x8>
    189c:	00 e1       	ldi	r16, 0x10	; 16
    189e:	ee cf       	rjmp	.-36     	; 0x187c <vfprintf+0x8c>
    18a0:	00 e0       	ldi	r16, 0x00	; 0
    18a2:	f2 cf       	rjmp	.-28     	; 0x1888 <vfprintf+0x98>
    18a4:	13 36       	cpi	r17, 0x63	; 99
    18a6:	09 f4       	brne	.+2      	; 0x18aa <vfprintf+0xba>
    18a8:	50 c0       	rjmp	.+160    	; 0x194a <vfprintf+0x15a>
    18aa:	13 37       	cpi	r17, 0x73	; 115
    18ac:	09 f4       	brne	.+2      	; 0x18b0 <vfprintf+0xc0>
    18ae:	54 c0       	rjmp	.+168    	; 0x1958 <vfprintf+0x168>
    18b0:	13 35       	cpi	r17, 0x53	; 83
    18b2:	09 f4       	brne	.+2      	; 0x18b6 <vfprintf+0xc6>
    18b4:	50 c0       	rjmp	.+160    	; 0x1956 <vfprintf+0x166>
    18b6:	14 36       	cpi	r17, 0x64	; 100
    18b8:	19 f0       	breq	.+6      	; 0x18c0 <vfprintf+0xd0>
    18ba:	19 36       	cpi	r17, 0x69	; 105
    18bc:	09 f0       	breq	.+2      	; 0x18c0 <vfprintf+0xd0>
    18be:	65 c0       	rjmp	.+202    	; 0x198a <vfprintf+0x19a>
    18c0:	f3 01       	movw	r30, r6
    18c2:	07 ff       	sbrs	r16, 7
    18c4:	5a c0       	rjmp	.+180    	; 0x197a <vfprintf+0x18a>
    18c6:	61 91       	ld	r22, Z+
    18c8:	71 91       	ld	r23, Z+
    18ca:	81 91       	ld	r24, Z+
    18cc:	91 91       	ld	r25, Z+
    18ce:	3f 01       	movw	r6, r30
    18d0:	0f 7e       	andi	r16, 0xEF	; 239
    18d2:	97 ff       	sbrs	r25, 7
    18d4:	08 c0       	rjmp	.+16     	; 0x18e6 <vfprintf+0xf6>
    18d6:	90 95       	com	r25
    18d8:	80 95       	com	r24
    18da:	70 95       	com	r23
    18dc:	61 95       	neg	r22
    18de:	7f 4f       	sbci	r23, 0xFF	; 255
    18e0:	8f 4f       	sbci	r24, 0xFF	; 255
    18e2:	9f 4f       	sbci	r25, 0xFF	; 255
    18e4:	00 64       	ori	r16, 0x40	; 64
    18e6:	2a e0       	ldi	r18, 0x0A	; 10
    18e8:	30 e0       	ldi	r19, 0x00	; 0
    18ea:	a4 01       	movw	r20, r8
    18ec:	13 d3       	rcall	.+1574   	; 0x1f14 <__ultoa_invert>
    18ee:	e8 2e       	mov	r14, r24
    18f0:	e8 18       	sub	r14, r8
    18f2:	06 ff       	sbrs	r16, 6
    18f4:	04 c0       	rjmp	.+8      	; 0x18fe <vfprintf+0x10e>
    18f6:	b5 01       	movw	r22, r10
    18f8:	8d e2       	ldi	r24, 0x2D	; 45
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	c3 d2       	rcall	.+1414   	; 0x1e84 <fputc>
    18fe:	04 ff       	sbrs	r16, 4
    1900:	13 c0       	rjmp	.+38     	; 0x1928 <vfprintf+0x138>
    1902:	fe 01       	movw	r30, r28
    1904:	ee 0d       	add	r30, r14
    1906:	f1 1d       	adc	r31, r1
    1908:	80 81       	ld	r24, Z
    190a:	80 33       	cpi	r24, 0x30	; 48
    190c:	69 f0       	breq	.+26     	; 0x1928 <vfprintf+0x138>
    190e:	b5 01       	movw	r22, r10
    1910:	80 e3       	ldi	r24, 0x30	; 48
    1912:	90 e0       	ldi	r25, 0x00	; 0
    1914:	b7 d2       	rcall	.+1390   	; 0x1e84 <fputc>
    1916:	02 ff       	sbrs	r16, 2
    1918:	07 c0       	rjmp	.+14     	; 0x1928 <vfprintf+0x138>
    191a:	80 2f       	mov	r24, r16
    191c:	80 72       	andi	r24, 0x20	; 32
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	b5 01       	movw	r22, r10
    1922:	88 5a       	subi	r24, 0xA8	; 168
    1924:	9f 4f       	sbci	r25, 0xFF	; 255
    1926:	ae d2       	rcall	.+1372   	; 0x1e84 <fputc>
    1928:	ea 94       	dec	r14
    192a:	f1 2c       	mov	r15, r1
    192c:	ff ef       	ldi	r31, 0xFF	; 255
    192e:	ef 1a       	sub	r14, r31
    1930:	ff 0a       	sbc	r15, r31
    1932:	e8 0c       	add	r14, r8
    1934:	f9 1c       	adc	r15, r9
    1936:	f7 01       	movw	r30, r14
    1938:	82 91       	ld	r24, -Z
    193a:	7f 01       	movw	r14, r30
    193c:	b5 01       	movw	r22, r10
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	a1 d2       	rcall	.+1346   	; 0x1e84 <fputc>
    1942:	e8 14       	cp	r14, r8
    1944:	f9 04       	cpc	r15, r9
    1946:	b9 f7       	brne	.-18     	; 0x1936 <vfprintf+0x146>
    1948:	64 cf       	rjmp	.-312    	; 0x1812 <vfprintf+0x22>
    194a:	b5 01       	movw	r22, r10
    194c:	f3 01       	movw	r30, r6
    194e:	81 91       	ld	r24, Z+
    1950:	91 91       	ld	r25, Z+
    1952:	3f 01       	movw	r6, r30
    1954:	75 cf       	rjmp	.-278    	; 0x1840 <vfprintf+0x50>
    1956:	01 60       	ori	r16, 0x01	; 1
    1958:	f3 01       	movw	r30, r6
    195a:	e1 90       	ld	r14, Z+
    195c:	f1 90       	ld	r15, Z+
    195e:	3f 01       	movw	r6, r30
    1960:	f7 01       	movw	r30, r14
    1962:	00 fd       	sbrc	r16, 0
    1964:	85 91       	lpm	r24, Z+
    1966:	00 ff       	sbrs	r16, 0
    1968:	81 91       	ld	r24, Z+
    196a:	7f 01       	movw	r14, r30
    196c:	88 23       	and	r24, r24
    196e:	09 f4       	brne	.+2      	; 0x1972 <vfprintf+0x182>
    1970:	50 cf       	rjmp	.-352    	; 0x1812 <vfprintf+0x22>
    1972:	b5 01       	movw	r22, r10
    1974:	90 e0       	ldi	r25, 0x00	; 0
    1976:	86 d2       	rcall	.+1292   	; 0x1e84 <fputc>
    1978:	f3 cf       	rjmp	.-26     	; 0x1960 <vfprintf+0x170>
    197a:	61 91       	ld	r22, Z+
    197c:	71 91       	ld	r23, Z+
    197e:	3f 01       	movw	r6, r30
    1980:	07 2e       	mov	r0, r23
    1982:	00 0c       	add	r0, r0
    1984:	88 0b       	sbc	r24, r24
    1986:	99 0b       	sbc	r25, r25
    1988:	a3 cf       	rjmp	.-186    	; 0x18d0 <vfprintf+0xe0>
    198a:	10 37       	cpi	r17, 0x70	; 112
    198c:	f1 f0       	breq	.+60     	; 0x19ca <vfprintf+0x1da>
    198e:	40 f4       	brcc	.+16     	; 0x19a0 <vfprintf+0x1b0>
    1990:	18 35       	cpi	r17, 0x58	; 88
    1992:	e9 f0       	breq	.+58     	; 0x19ce <vfprintf+0x1de>
    1994:	1f 36       	cpi	r17, 0x6F	; 111
    1996:	09 f0       	breq	.+2      	; 0x199a <vfprintf+0x1aa>
    1998:	7b cf       	rjmp	.-266    	; 0x1890 <vfprintf+0xa0>
    199a:	28 e0       	ldi	r18, 0x08	; 8
    199c:	30 e0       	ldi	r19, 0x00	; 0
    199e:	0c c0       	rjmp	.+24     	; 0x19b8 <vfprintf+0x1c8>
    19a0:	15 37       	cpi	r17, 0x75	; 117
    19a2:	39 f0       	breq	.+14     	; 0x19b2 <vfprintf+0x1c2>
    19a4:	18 37       	cpi	r17, 0x78	; 120
    19a6:	09 f0       	breq	.+2      	; 0x19aa <vfprintf+0x1ba>
    19a8:	73 cf       	rjmp	.-282    	; 0x1890 <vfprintf+0xa0>
    19aa:	04 62       	ori	r16, 0x24	; 36
    19ac:	20 e1       	ldi	r18, 0x10	; 16
    19ae:	30 e0       	ldi	r19, 0x00	; 0
    19b0:	03 c0       	rjmp	.+6      	; 0x19b8 <vfprintf+0x1c8>
    19b2:	0f 7e       	andi	r16, 0xEF	; 239
    19b4:	2a e0       	ldi	r18, 0x0A	; 10
    19b6:	30 e0       	ldi	r19, 0x00	; 0
    19b8:	f3 01       	movw	r30, r6
    19ba:	07 ff       	sbrs	r16, 7
    19bc:	0c c0       	rjmp	.+24     	; 0x19d6 <vfprintf+0x1e6>
    19be:	61 91       	ld	r22, Z+
    19c0:	71 91       	ld	r23, Z+
    19c2:	81 91       	ld	r24, Z+
    19c4:	91 91       	ld	r25, Z+
    19c6:	3f 01       	movw	r6, r30
    19c8:	90 cf       	rjmp	.-224    	; 0x18ea <vfprintf+0xfa>
    19ca:	00 61       	ori	r16, 0x10	; 16
    19cc:	ee cf       	rjmp	.-36     	; 0x19aa <vfprintf+0x1ba>
    19ce:	04 60       	ori	r16, 0x04	; 4
    19d0:	20 e1       	ldi	r18, 0x10	; 16
    19d2:	32 e0       	ldi	r19, 0x02	; 2
    19d4:	f1 cf       	rjmp	.-30     	; 0x19b8 <vfprintf+0x1c8>
    19d6:	61 91       	ld	r22, Z+
    19d8:	71 91       	ld	r23, Z+
    19da:	3f 01       	movw	r6, r30
    19dc:	90 e0       	ldi	r25, 0x00	; 0
    19de:	80 e0       	ldi	r24, 0x00	; 0
    19e0:	84 cf       	rjmp	.-248    	; 0x18ea <vfprintf+0xfa>
    19e2:	8f ef       	ldi	r24, 0xFF	; 255
    19e4:	9f ef       	ldi	r25, 0xFF	; 255
    19e6:	57 cf       	rjmp	.-338    	; 0x1896 <vfprintf+0xa6>

000019e8 <putval>:
    19e8:	20 fd       	sbrc	r18, 0
    19ea:	09 c0       	rjmp	.+18     	; 0x19fe <putval+0x16>
    19ec:	fc 01       	movw	r30, r24
    19ee:	23 fd       	sbrc	r18, 3
    19f0:	05 c0       	rjmp	.+10     	; 0x19fc <putval+0x14>
    19f2:	22 ff       	sbrs	r18, 2
    19f4:	02 c0       	rjmp	.+4      	; 0x19fa <putval+0x12>
    19f6:	73 83       	std	Z+3, r23	; 0x03
    19f8:	62 83       	std	Z+2, r22	; 0x02
    19fa:	51 83       	std	Z+1, r21	; 0x01
    19fc:	40 83       	st	Z, r20
    19fe:	08 95       	ret

00001a00 <mulacc>:
    1a00:	33 e0       	ldi	r19, 0x03	; 3
    1a02:	44 fd       	sbrc	r20, 4
    1a04:	10 c0       	rjmp	.+32     	; 0x1a26 <mulacc+0x26>
    1a06:	34 e0       	ldi	r19, 0x04	; 4
    1a08:	46 fd       	sbrc	r20, 6
    1a0a:	0d c0       	rjmp	.+26     	; 0x1a26 <mulacc+0x26>
    1a0c:	db 01       	movw	r26, r22
    1a0e:	fc 01       	movw	r30, r24
    1a10:	aa 0f       	add	r26, r26
    1a12:	bb 1f       	adc	r27, r27
    1a14:	ee 1f       	adc	r30, r30
    1a16:	ff 1f       	adc	r31, r31
    1a18:	10 94       	com	r1
    1a1a:	d1 f7       	brne	.-12     	; 0x1a10 <mulacc+0x10>
    1a1c:	6a 0f       	add	r22, r26
    1a1e:	7b 1f       	adc	r23, r27
    1a20:	8e 1f       	adc	r24, r30
    1a22:	9f 1f       	adc	r25, r31
    1a24:	31 e0       	ldi	r19, 0x01	; 1
    1a26:	66 0f       	add	r22, r22
    1a28:	77 1f       	adc	r23, r23
    1a2a:	88 1f       	adc	r24, r24
    1a2c:	99 1f       	adc	r25, r25
    1a2e:	31 50       	subi	r19, 0x01	; 1
    1a30:	d1 f7       	brne	.-12     	; 0x1a26 <mulacc+0x26>
    1a32:	62 0f       	add	r22, r18
    1a34:	71 1d       	adc	r23, r1
    1a36:	81 1d       	adc	r24, r1
    1a38:	91 1d       	adc	r25, r1
    1a3a:	08 95       	ret

00001a3c <skip_spaces>:
    1a3c:	0f 93       	push	r16
    1a3e:	1f 93       	push	r17
    1a40:	cf 93       	push	r28
    1a42:	df 93       	push	r29
    1a44:	8c 01       	movw	r16, r24
    1a46:	c8 01       	movw	r24, r16
    1a48:	e3 d1       	rcall	.+966    	; 0x1e10 <fgetc>
    1a4a:	ec 01       	movw	r28, r24
    1a4c:	97 fd       	sbrc	r25, 7
    1a4e:	06 c0       	rjmp	.+12     	; 0x1a5c <skip_spaces+0x20>
    1a50:	c3 d1       	rcall	.+902    	; 0x1dd8 <isspace>
    1a52:	89 2b       	or	r24, r25
    1a54:	c1 f7       	brne	.-16     	; 0x1a46 <skip_spaces+0xa>
    1a56:	b8 01       	movw	r22, r16
    1a58:	ce 01       	movw	r24, r28
    1a5a:	44 d2       	rcall	.+1160   	; 0x1ee4 <ungetc>
    1a5c:	ce 01       	movw	r24, r28
    1a5e:	df 91       	pop	r29
    1a60:	cf 91       	pop	r28
    1a62:	1f 91       	pop	r17
    1a64:	0f 91       	pop	r16
    1a66:	08 95       	ret

00001a68 <conv_int>:
    1a68:	8f 92       	push	r8
    1a6a:	9f 92       	push	r9
    1a6c:	af 92       	push	r10
    1a6e:	bf 92       	push	r11
    1a70:	ef 92       	push	r14
    1a72:	ff 92       	push	r15
    1a74:	0f 93       	push	r16
    1a76:	1f 93       	push	r17
    1a78:	cf 93       	push	r28
    1a7a:	df 93       	push	r29
    1a7c:	8c 01       	movw	r16, r24
    1a7e:	d6 2f       	mov	r29, r22
    1a80:	7a 01       	movw	r14, r20
    1a82:	b2 2e       	mov	r11, r18
    1a84:	c5 d1       	rcall	.+906    	; 0x1e10 <fgetc>
    1a86:	9c 01       	movw	r18, r24
    1a88:	33 27       	eor	r19, r19
    1a8a:	2b 32       	cpi	r18, 0x2B	; 43
    1a8c:	31 05       	cpc	r19, r1
    1a8e:	29 f0       	breq	.+10     	; 0x1a9a <conv_int+0x32>
    1a90:	2d 32       	cpi	r18, 0x2D	; 45
    1a92:	31 05       	cpc	r19, r1
    1a94:	a1 f4       	brne	.+40     	; 0x1abe <conv_int+0x56>
    1a96:	68 94       	set
    1a98:	b7 f8       	bld	r11, 7
    1a9a:	d1 50       	subi	r29, 0x01	; 1
    1a9c:	61 f4       	brne	.+24     	; 0x1ab6 <conv_int+0x4e>
    1a9e:	80 e0       	ldi	r24, 0x00	; 0
    1aa0:	df 91       	pop	r29
    1aa2:	cf 91       	pop	r28
    1aa4:	1f 91       	pop	r17
    1aa6:	0f 91       	pop	r16
    1aa8:	ff 90       	pop	r15
    1aaa:	ef 90       	pop	r14
    1aac:	bf 90       	pop	r11
    1aae:	af 90       	pop	r10
    1ab0:	9f 90       	pop	r9
    1ab2:	8f 90       	pop	r8
    1ab4:	08 95       	ret
    1ab6:	c8 01       	movw	r24, r16
    1ab8:	ab d1       	rcall	.+854    	; 0x1e10 <fgetc>
    1aba:	97 fd       	sbrc	r25, 7
    1abc:	f0 cf       	rjmp	.-32     	; 0x1a9e <conv_int+0x36>
    1abe:	cb 2d       	mov	r28, r11
    1ac0:	cd 7f       	andi	r28, 0xFD	; 253
    1ac2:	2b 2d       	mov	r18, r11
    1ac4:	20 73       	andi	r18, 0x30	; 48
    1ac6:	e9 f4       	brne	.+58     	; 0x1b02 <conv_int+0x9a>
    1ac8:	80 33       	cpi	r24, 0x30	; 48
    1aca:	d9 f4       	brne	.+54     	; 0x1b02 <conv_int+0x9a>
    1acc:	aa 24       	eor	r10, r10
    1ace:	aa 94       	dec	r10
    1ad0:	ad 0e       	add	r10, r29
    1ad2:	79 f0       	breq	.+30     	; 0x1af2 <conv_int+0x8a>
    1ad4:	c8 01       	movw	r24, r16
    1ad6:	9c d1       	rcall	.+824    	; 0x1e10 <fgetc>
    1ad8:	97 fd       	sbrc	r25, 7
    1ada:	0b c0       	rjmp	.+22     	; 0x1af2 <conv_int+0x8a>
    1adc:	28 2f       	mov	r18, r24
    1ade:	2f 7d       	andi	r18, 0xDF	; 223
    1ae0:	28 35       	cpi	r18, 0x58	; 88
    1ae2:	59 f4       	brne	.+22     	; 0x1afa <conv_int+0x92>
    1ae4:	c2 64       	ori	r28, 0x42	; 66
    1ae6:	d2 50       	subi	r29, 0x02	; 2
    1ae8:	21 f0       	breq	.+8      	; 0x1af2 <conv_int+0x8a>
    1aea:	c8 01       	movw	r24, r16
    1aec:	91 d1       	rcall	.+802    	; 0x1e10 <fgetc>
    1aee:	97 ff       	sbrs	r25, 7
    1af0:	08 c0       	rjmp	.+16     	; 0x1b02 <conv_int+0x9a>
    1af2:	81 2c       	mov	r8, r1
    1af4:	91 2c       	mov	r9, r1
    1af6:	54 01       	movw	r10, r8
    1af8:	1a c0       	rjmp	.+52     	; 0x1b2e <conv_int+0xc6>
    1afa:	b6 fe       	sbrs	r11, 6
    1afc:	29 c0       	rjmp	.+82     	; 0x1b50 <conv_int+0xe8>
    1afe:	c2 60       	ori	r28, 0x02	; 2
    1b00:	da 2d       	mov	r29, r10
    1b02:	81 2c       	mov	r8, r1
    1b04:	91 2c       	mov	r9, r1
    1b06:	54 01       	movw	r10, r8
    1b08:	20 ed       	ldi	r18, 0xD0	; 208
    1b0a:	28 0f       	add	r18, r24
    1b0c:	28 30       	cpi	r18, 0x08	; 8
    1b0e:	18 f1       	brcs	.+70     	; 0x1b56 <conv_int+0xee>
    1b10:	c4 fd       	sbrc	r28, 4
    1b12:	09 c0       	rjmp	.+18     	; 0x1b26 <conv_int+0xbe>
    1b14:	2a 30       	cpi	r18, 0x0A	; 10
    1b16:	f8 f0       	brcs	.+62     	; 0x1b56 <conv_int+0xee>
    1b18:	c6 ff       	sbrs	r28, 6
    1b1a:	05 c0       	rjmp	.+10     	; 0x1b26 <conv_int+0xbe>
    1b1c:	2f 7d       	andi	r18, 0xDF	; 223
    1b1e:	3f ee       	ldi	r19, 0xEF	; 239
    1b20:	32 0f       	add	r19, r18
    1b22:	36 30       	cpi	r19, 0x06	; 6
    1b24:	b8 f0       	brcs	.+46     	; 0x1b54 <conv_int+0xec>
    1b26:	b8 01       	movw	r22, r16
    1b28:	dd d1       	rcall	.+954    	; 0x1ee4 <ungetc>
    1b2a:	c1 ff       	sbrs	r28, 1
    1b2c:	b8 cf       	rjmp	.-144    	; 0x1a9e <conv_int+0x36>
    1b2e:	c7 ff       	sbrs	r28, 7
    1b30:	08 c0       	rjmp	.+16     	; 0x1b42 <conv_int+0xda>
    1b32:	b0 94       	com	r11
    1b34:	a0 94       	com	r10
    1b36:	90 94       	com	r9
    1b38:	80 94       	com	r8
    1b3a:	81 1c       	adc	r8, r1
    1b3c:	91 1c       	adc	r9, r1
    1b3e:	a1 1c       	adc	r10, r1
    1b40:	b1 1c       	adc	r11, r1
    1b42:	2c 2f       	mov	r18, r28
    1b44:	b5 01       	movw	r22, r10
    1b46:	a4 01       	movw	r20, r8
    1b48:	c7 01       	movw	r24, r14
    1b4a:	4e df       	rcall	.-356    	; 0x19e8 <putval>
    1b4c:	81 e0       	ldi	r24, 0x01	; 1
    1b4e:	a8 cf       	rjmp	.-176    	; 0x1aa0 <conv_int+0x38>
    1b50:	c2 61       	ori	r28, 0x12	; 18
    1b52:	d6 cf       	rjmp	.-84     	; 0x1b00 <conv_int+0x98>
    1b54:	27 50       	subi	r18, 0x07	; 7
    1b56:	4c 2f       	mov	r20, r28
    1b58:	c5 01       	movw	r24, r10
    1b5a:	b4 01       	movw	r22, r8
    1b5c:	51 df       	rcall	.-350    	; 0x1a00 <mulacc>
    1b5e:	4b 01       	movw	r8, r22
    1b60:	5c 01       	movw	r10, r24
    1b62:	c2 60       	ori	r28, 0x02	; 2
    1b64:	d1 50       	subi	r29, 0x01	; 1
    1b66:	19 f3       	breq	.-58     	; 0x1b2e <conv_int+0xc6>
    1b68:	c8 01       	movw	r24, r16
    1b6a:	52 d1       	rcall	.+676    	; 0x1e10 <fgetc>
    1b6c:	97 ff       	sbrs	r25, 7
    1b6e:	cc cf       	rjmp	.-104    	; 0x1b08 <conv_int+0xa0>
    1b70:	de cf       	rjmp	.-68     	; 0x1b2e <conv_int+0xc6>

00001b72 <vfscanf>:
    1b72:	b0 e0       	ldi	r27, 0x00	; 0
    1b74:	a0 e0       	ldi	r26, 0x00	; 0
    1b76:	ee eb       	ldi	r30, 0xBE	; 190
    1b78:	fd e0       	ldi	r31, 0x0D	; 13
    1b7a:	fb c0       	rjmp	.+502    	; 0x1d72 <__prologue_saves__+0x8>
    1b7c:	5c 01       	movw	r10, r24
    1b7e:	eb 01       	movw	r28, r22
    1b80:	74 2e       	mov	r7, r20
    1b82:	65 2e       	mov	r6, r21
    1b84:	fc 01       	movw	r30, r24
    1b86:	17 82       	std	Z+7, r1	; 0x07
    1b88:	16 82       	std	Z+6, r1	; 0x06
    1b8a:	c1 2c       	mov	r12, r1
    1b8c:	f5 01       	movw	r30, r10
    1b8e:	f3 80       	ldd	r15, Z+3	; 0x03
    1b90:	fe 01       	movw	r30, r28
    1b92:	f3 fc       	sbrc	r15, 3
    1b94:	85 91       	lpm	r24, Z+
    1b96:	f3 fe       	sbrs	r15, 3
    1b98:	81 91       	ld	r24, Z+
    1b9a:	18 2f       	mov	r17, r24
    1b9c:	ef 01       	movw	r28, r30
    1b9e:	88 23       	and	r24, r24
    1ba0:	c9 f0       	breq	.+50     	; 0x1bd4 <vfscanf+0x62>
    1ba2:	90 e0       	ldi	r25, 0x00	; 0
    1ba4:	19 d1       	rcall	.+562    	; 0x1dd8 <isspace>
    1ba6:	89 2b       	or	r24, r25
    1ba8:	19 f0       	breq	.+6      	; 0x1bb0 <vfscanf+0x3e>
    1baa:	c5 01       	movw	r24, r10
    1bac:	47 df       	rcall	.-370    	; 0x1a3c <skip_spaces>
    1bae:	ee cf       	rjmp	.-36     	; 0x1b8c <vfscanf+0x1a>
    1bb0:	15 32       	cpi	r17, 0x25	; 37
    1bb2:	41 f4       	brne	.+16     	; 0x1bc4 <vfscanf+0x52>
    1bb4:	fe 01       	movw	r30, r28
    1bb6:	f3 fc       	sbrc	r15, 3
    1bb8:	15 91       	lpm	r17, Z+
    1bba:	f3 fe       	sbrs	r15, 3
    1bbc:	11 91       	ld	r17, Z+
    1bbe:	ef 01       	movw	r28, r30
    1bc0:	15 32       	cpi	r17, 0x25	; 37
    1bc2:	59 f4       	brne	.+22     	; 0x1bda <vfscanf+0x68>
    1bc4:	c5 01       	movw	r24, r10
    1bc6:	24 d1       	rcall	.+584    	; 0x1e10 <fgetc>
    1bc8:	97 fd       	sbrc	r25, 7
    1bca:	96 c0       	rjmp	.+300    	; 0x1cf8 <vfscanf+0x186>
    1bcc:	18 17       	cp	r17, r24
    1bce:	f1 f2       	breq	.-68     	; 0x1b8c <vfscanf+0x1a>
    1bd0:	b5 01       	movw	r22, r10
    1bd2:	88 d1       	rcall	.+784    	; 0x1ee4 <ungetc>
    1bd4:	8c 2d       	mov	r24, r12
    1bd6:	90 e0       	ldi	r25, 0x00	; 0
    1bd8:	93 c0       	rjmp	.+294    	; 0x1d00 <vfscanf+0x18e>
    1bda:	00 e0       	ldi	r16, 0x00	; 0
    1bdc:	1a 32       	cpi	r17, 0x2A	; 42
    1bde:	31 f4       	brne	.+12     	; 0x1bec <vfscanf+0x7a>
    1be0:	f3 fc       	sbrc	r15, 3
    1be2:	15 91       	lpm	r17, Z+
    1be4:	f3 fe       	sbrs	r15, 3
    1be6:	11 91       	ld	r17, Z+
    1be8:	ef 01       	movw	r28, r30
    1bea:	01 e0       	ldi	r16, 0x01	; 1
    1bec:	d1 2c       	mov	r13, r1
    1bee:	20 ed       	ldi	r18, 0xD0	; 208
    1bf0:	21 0f       	add	r18, r17
    1bf2:	2a 30       	cpi	r18, 0x0A	; 10
    1bf4:	38 f1       	brcs	.+78     	; 0x1c44 <vfscanf+0xd2>
    1bf6:	01 ff       	sbrs	r16, 1
    1bf8:	34 c0       	rjmp	.+104    	; 0x1c62 <vfscanf+0xf0>
    1bfa:	dd 20       	and	r13, r13
    1bfc:	59 f3       	breq	.-42     	; 0x1bd4 <vfscanf+0x62>
    1bfe:	18 36       	cpi	r17, 0x68	; 104
    1c00:	99 f1       	breq	.+102    	; 0x1c68 <vfscanf+0xf6>
    1c02:	1c 36       	cpi	r17, 0x6C	; 108
    1c04:	09 f4       	brne	.+2      	; 0x1c08 <vfscanf+0x96>
    1c06:	3a c0       	rjmp	.+116    	; 0x1c7c <vfscanf+0x10a>
    1c08:	11 23       	and	r17, r17
    1c0a:	21 f3       	breq	.-56     	; 0x1bd4 <vfscanf+0x62>
    1c0c:	61 2f       	mov	r22, r17
    1c0e:	70 e0       	ldi	r23, 0x00	; 0
    1c10:	8f e7       	ldi	r24, 0x7F	; 127
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	e9 d0       	rcall	.+466    	; 0x1de8 <strchr_P>
    1c16:	89 2b       	or	r24, r25
    1c18:	e9 f2       	breq	.-70     	; 0x1bd4 <vfscanf+0x62>
    1c1a:	f1 2c       	mov	r15, r1
    1c1c:	e1 2c       	mov	r14, r1
    1c1e:	00 fd       	sbrc	r16, 0
    1c20:	06 c0       	rjmp	.+12     	; 0x1c2e <vfscanf+0xbc>
    1c22:	e7 2d       	mov	r30, r7
    1c24:	f6 2d       	mov	r31, r6
    1c26:	e1 90       	ld	r14, Z+
    1c28:	f1 90       	ld	r15, Z+
    1c2a:	7e 2e       	mov	r7, r30
    1c2c:	6f 2e       	mov	r6, r31
    1c2e:	1e 36       	cpi	r17, 0x6E	; 110
    1c30:	69 f5       	brne	.+90     	; 0x1c8c <vfscanf+0x11a>
    1c32:	f5 01       	movw	r30, r10
    1c34:	46 81       	ldd	r20, Z+6	; 0x06
    1c36:	57 81       	ldd	r21, Z+7	; 0x07
    1c38:	70 e0       	ldi	r23, 0x00	; 0
    1c3a:	60 e0       	ldi	r22, 0x00	; 0
    1c3c:	20 2f       	mov	r18, r16
    1c3e:	c7 01       	movw	r24, r14
    1c40:	d3 de       	rcall	.-602    	; 0x19e8 <putval>
    1c42:	a4 cf       	rjmp	.-184    	; 0x1b8c <vfscanf+0x1a>
    1c44:	02 60       	ori	r16, 0x02	; 2
    1c46:	6d 2d       	mov	r22, r13
    1c48:	70 e0       	ldi	r23, 0x00	; 0
    1c4a:	90 e0       	ldi	r25, 0x00	; 0
    1c4c:	80 e0       	ldi	r24, 0x00	; 0
    1c4e:	40 e2       	ldi	r20, 0x20	; 32
    1c50:	d7 de       	rcall	.-594    	; 0x1a00 <mulacc>
    1c52:	d6 2e       	mov	r13, r22
    1c54:	fe 01       	movw	r30, r28
    1c56:	f3 fc       	sbrc	r15, 3
    1c58:	15 91       	lpm	r17, Z+
    1c5a:	f3 fe       	sbrs	r15, 3
    1c5c:	11 91       	ld	r17, Z+
    1c5e:	ef 01       	movw	r28, r30
    1c60:	c6 cf       	rjmp	.-116    	; 0x1bee <vfscanf+0x7c>
    1c62:	dd 24       	eor	r13, r13
    1c64:	da 94       	dec	r13
    1c66:	cb cf       	rjmp	.-106    	; 0x1bfe <vfscanf+0x8c>
    1c68:	fe 01       	movw	r30, r28
    1c6a:	f3 fc       	sbrc	r15, 3
    1c6c:	15 91       	lpm	r17, Z+
    1c6e:	f3 fe       	sbrs	r15, 3
    1c70:	11 91       	ld	r17, Z+
    1c72:	ef 01       	movw	r28, r30
    1c74:	18 36       	cpi	r17, 0x68	; 104
    1c76:	09 f0       	breq	.+2      	; 0x1c7a <vfscanf+0x108>
    1c78:	c7 cf       	rjmp	.-114    	; 0x1c08 <vfscanf+0x96>
    1c7a:	08 60       	ori	r16, 0x08	; 8
    1c7c:	04 60       	ori	r16, 0x04	; 4
    1c7e:	fe 01       	movw	r30, r28
    1c80:	f3 fc       	sbrc	r15, 3
    1c82:	15 91       	lpm	r17, Z+
    1c84:	f3 fe       	sbrs	r15, 3
    1c86:	11 91       	ld	r17, Z+
    1c88:	ef 01       	movw	r28, r30
    1c8a:	be cf       	rjmp	.-132    	; 0x1c08 <vfscanf+0x96>
    1c8c:	13 36       	cpi	r17, 0x63	; 99
    1c8e:	a9 f4       	brne	.+42     	; 0x1cba <vfscanf+0x148>
    1c90:	01 fd       	sbrc	r16, 1
    1c92:	02 c0       	rjmp	.+4      	; 0x1c98 <vfscanf+0x126>
    1c94:	dd 24       	eor	r13, r13
    1c96:	d3 94       	inc	r13
    1c98:	c5 01       	movw	r24, r10
    1c9a:	ba d0       	rcall	.+372    	; 0x1e10 <fgetc>
    1c9c:	97 fd       	sbrc	r25, 7
    1c9e:	2c c0       	rjmp	.+88     	; 0x1cf8 <vfscanf+0x186>
    1ca0:	e1 14       	cp	r14, r1
    1ca2:	f1 04       	cpc	r15, r1
    1ca4:	19 f0       	breq	.+6      	; 0x1cac <vfscanf+0x13a>
    1ca6:	f7 01       	movw	r30, r14
    1ca8:	81 93       	st	Z+, r24
    1caa:	7f 01       	movw	r14, r30
    1cac:	da 94       	dec	r13
    1cae:	d1 10       	cpse	r13, r1
    1cb0:	f3 cf       	rjmp	.-26     	; 0x1c98 <vfscanf+0x126>
    1cb2:	00 fd       	sbrc	r16, 0
    1cb4:	6b cf       	rjmp	.-298    	; 0x1b8c <vfscanf+0x1a>
    1cb6:	c3 94       	inc	r12
    1cb8:	69 cf       	rjmp	.-302    	; 0x1b8c <vfscanf+0x1a>
    1cba:	c5 01       	movw	r24, r10
    1cbc:	bf de       	rcall	.-642    	; 0x1a3c <skip_spaces>
    1cbe:	97 fd       	sbrc	r25, 7
    1cc0:	1b c0       	rjmp	.+54     	; 0x1cf8 <vfscanf+0x186>
    1cc2:	1f 36       	cpi	r17, 0x6F	; 111
    1cc4:	09 f4       	brne	.+2      	; 0x1cc8 <vfscanf+0x156>
    1cc6:	3b c0       	rjmp	.+118    	; 0x1d3e <vfscanf+0x1cc>
    1cc8:	30 f4       	brcc	.+12     	; 0x1cd6 <vfscanf+0x164>
    1cca:	14 36       	cpi	r17, 0x64	; 100
    1ccc:	41 f0       	breq	.+16     	; 0x1cde <vfscanf+0x16c>
    1cce:	19 36       	cpi	r17, 0x69	; 105
    1cd0:	39 f0       	breq	.+14     	; 0x1ce0 <vfscanf+0x16e>
    1cd2:	00 64       	ori	r16, 0x40	; 64
    1cd4:	05 c0       	rjmp	.+10     	; 0x1ce0 <vfscanf+0x16e>
    1cd6:	13 37       	cpi	r17, 0x73	; 115
    1cd8:	01 f1       	breq	.+64     	; 0x1d1a <vfscanf+0x1a8>
    1cda:	15 37       	cpi	r17, 0x75	; 117
    1cdc:	d1 f7       	brne	.-12     	; 0x1cd2 <vfscanf+0x160>
    1cde:	00 62       	ori	r16, 0x20	; 32
    1ce0:	20 2f       	mov	r18, r16
    1ce2:	a7 01       	movw	r20, r14
    1ce4:	6d 2d       	mov	r22, r13
    1ce6:	c5 01       	movw	r24, r10
    1ce8:	bf de       	rcall	.-642    	; 0x1a68 <conv_int>
    1cea:	81 11       	cpse	r24, r1
    1cec:	e2 cf       	rjmp	.-60     	; 0x1cb2 <vfscanf+0x140>
    1cee:	f5 01       	movw	r30, r10
    1cf0:	83 81       	ldd	r24, Z+3	; 0x03
    1cf2:	80 73       	andi	r24, 0x30	; 48
    1cf4:	09 f4       	brne	.+2      	; 0x1cf8 <vfscanf+0x186>
    1cf6:	6e cf       	rjmp	.-292    	; 0x1bd4 <vfscanf+0x62>
    1cf8:	8f ef       	ldi	r24, 0xFF	; 255
    1cfa:	9f ef       	ldi	r25, 0xFF	; 255
    1cfc:	c1 10       	cpse	r12, r1
    1cfe:	6a cf       	rjmp	.-300    	; 0x1bd4 <vfscanf+0x62>
    1d00:	cd b7       	in	r28, 0x3d	; 61
    1d02:	de b7       	in	r29, 0x3e	; 62
    1d04:	ee e0       	ldi	r30, 0x0E	; 14
    1d06:	51 c0       	rjmp	.+162    	; 0x1daa <__epilogue_restores__+0x8>
    1d08:	e1 14       	cp	r14, r1
    1d0a:	f1 04       	cpc	r15, r1
    1d0c:	19 f0       	breq	.+6      	; 0x1d14 <vfscanf+0x1a2>
    1d0e:	f7 01       	movw	r30, r14
    1d10:	81 92       	st	Z+, r8
    1d12:	7f 01       	movw	r14, r30
    1d14:	da 94       	dec	r13
    1d16:	dd 20       	and	r13, r13
    1d18:	59 f0       	breq	.+22     	; 0x1d30 <vfscanf+0x1be>
    1d1a:	c5 01       	movw	r24, r10
    1d1c:	79 d0       	rcall	.+242    	; 0x1e10 <fgetc>
    1d1e:	4c 01       	movw	r8, r24
    1d20:	97 fd       	sbrc	r25, 7
    1d22:	06 c0       	rjmp	.+12     	; 0x1d30 <vfscanf+0x1be>
    1d24:	59 d0       	rcall	.+178    	; 0x1dd8 <isspace>
    1d26:	89 2b       	or	r24, r25
    1d28:	79 f3       	breq	.-34     	; 0x1d08 <vfscanf+0x196>
    1d2a:	b5 01       	movw	r22, r10
    1d2c:	c4 01       	movw	r24, r8
    1d2e:	da d0       	rcall	.+436    	; 0x1ee4 <ungetc>
    1d30:	e1 14       	cp	r14, r1
    1d32:	f1 04       	cpc	r15, r1
    1d34:	09 f4       	brne	.+2      	; 0x1d38 <vfscanf+0x1c6>
    1d36:	bd cf       	rjmp	.-134    	; 0x1cb2 <vfscanf+0x140>
    1d38:	f7 01       	movw	r30, r14
    1d3a:	10 82       	st	Z, r1
    1d3c:	ba cf       	rjmp	.-140    	; 0x1cb2 <vfscanf+0x140>
    1d3e:	00 61       	ori	r16, 0x10	; 16
    1d40:	cf cf       	rjmp	.-98     	; 0x1ce0 <vfscanf+0x16e>

00001d42 <__udivmodhi4>:
    1d42:	aa 1b       	sub	r26, r26
    1d44:	bb 1b       	sub	r27, r27
    1d46:	51 e1       	ldi	r21, 0x11	; 17
    1d48:	07 c0       	rjmp	.+14     	; 0x1d58 <__udivmodhi4_ep>

00001d4a <__udivmodhi4_loop>:
    1d4a:	aa 1f       	adc	r26, r26
    1d4c:	bb 1f       	adc	r27, r27
    1d4e:	a6 17       	cp	r26, r22
    1d50:	b7 07       	cpc	r27, r23
    1d52:	10 f0       	brcs	.+4      	; 0x1d58 <__udivmodhi4_ep>
    1d54:	a6 1b       	sub	r26, r22
    1d56:	b7 0b       	sbc	r27, r23

00001d58 <__udivmodhi4_ep>:
    1d58:	88 1f       	adc	r24, r24
    1d5a:	99 1f       	adc	r25, r25
    1d5c:	5a 95       	dec	r21
    1d5e:	a9 f7       	brne	.-22     	; 0x1d4a <__udivmodhi4_loop>
    1d60:	80 95       	com	r24
    1d62:	90 95       	com	r25
    1d64:	bc 01       	movw	r22, r24
    1d66:	cd 01       	movw	r24, r26
    1d68:	08 95       	ret

00001d6a <__prologue_saves__>:
    1d6a:	2f 92       	push	r2
    1d6c:	3f 92       	push	r3
    1d6e:	4f 92       	push	r4
    1d70:	5f 92       	push	r5
    1d72:	6f 92       	push	r6
    1d74:	7f 92       	push	r7
    1d76:	8f 92       	push	r8
    1d78:	9f 92       	push	r9
    1d7a:	af 92       	push	r10
    1d7c:	bf 92       	push	r11
    1d7e:	cf 92       	push	r12
    1d80:	df 92       	push	r13
    1d82:	ef 92       	push	r14
    1d84:	ff 92       	push	r15
    1d86:	0f 93       	push	r16
    1d88:	1f 93       	push	r17
    1d8a:	cf 93       	push	r28
    1d8c:	df 93       	push	r29
    1d8e:	cd b7       	in	r28, 0x3d	; 61
    1d90:	de b7       	in	r29, 0x3e	; 62
    1d92:	ca 1b       	sub	r28, r26
    1d94:	db 0b       	sbc	r29, r27
    1d96:	0f b6       	in	r0, 0x3f	; 63
    1d98:	f8 94       	cli
    1d9a:	de bf       	out	0x3e, r29	; 62
    1d9c:	0f be       	out	0x3f, r0	; 63
    1d9e:	cd bf       	out	0x3d, r28	; 61
    1da0:	09 94       	ijmp

00001da2 <__epilogue_restores__>:
    1da2:	2a 88       	ldd	r2, Y+18	; 0x12
    1da4:	39 88       	ldd	r3, Y+17	; 0x11
    1da6:	48 88       	ldd	r4, Y+16	; 0x10
    1da8:	5f 84       	ldd	r5, Y+15	; 0x0f
    1daa:	6e 84       	ldd	r6, Y+14	; 0x0e
    1dac:	7d 84       	ldd	r7, Y+13	; 0x0d
    1dae:	8c 84       	ldd	r8, Y+12	; 0x0c
    1db0:	9b 84       	ldd	r9, Y+11	; 0x0b
    1db2:	aa 84       	ldd	r10, Y+10	; 0x0a
    1db4:	b9 84       	ldd	r11, Y+9	; 0x09
    1db6:	c8 84       	ldd	r12, Y+8	; 0x08
    1db8:	df 80       	ldd	r13, Y+7	; 0x07
    1dba:	ee 80       	ldd	r14, Y+6	; 0x06
    1dbc:	fd 80       	ldd	r15, Y+5	; 0x05
    1dbe:	0c 81       	ldd	r16, Y+4	; 0x04
    1dc0:	1b 81       	ldd	r17, Y+3	; 0x03
    1dc2:	aa 81       	ldd	r26, Y+2	; 0x02
    1dc4:	b9 81       	ldd	r27, Y+1	; 0x01
    1dc6:	ce 0f       	add	r28, r30
    1dc8:	d1 1d       	adc	r29, r1
    1dca:	0f b6       	in	r0, 0x3f	; 63
    1dcc:	f8 94       	cli
    1dce:	de bf       	out	0x3e, r29	; 62
    1dd0:	0f be       	out	0x3f, r0	; 63
    1dd2:	cd bf       	out	0x3d, r28	; 61
    1dd4:	ed 01       	movw	r28, r26
    1dd6:	08 95       	ret

00001dd8 <isspace>:
    1dd8:	91 11       	cpse	r25, r1
    1dda:	fa c0       	rjmp	.+500    	; 0x1fd0 <__ctype_isfalse>
    1ddc:	80 32       	cpi	r24, 0x20	; 32
    1dde:	19 f0       	breq	.+6      	; 0x1de6 <isspace+0xe>
    1de0:	89 50       	subi	r24, 0x09	; 9
    1de2:	85 50       	subi	r24, 0x05	; 5
    1de4:	d0 f7       	brcc	.-12     	; 0x1dda <isspace+0x2>
    1de6:	08 95       	ret

00001de8 <strchr_P>:
    1de8:	fc 01       	movw	r30, r24
    1dea:	05 90       	lpm	r0, Z+
    1dec:	06 16       	cp	r0, r22
    1dee:	21 f0       	breq	.+8      	; 0x1df8 <strchr_P+0x10>
    1df0:	00 20       	and	r0, r0
    1df2:	d9 f7       	brne	.-10     	; 0x1dea <strchr_P+0x2>
    1df4:	c0 01       	movw	r24, r0
    1df6:	08 95       	ret
    1df8:	31 97       	sbiw	r30, 0x01	; 1
    1dfa:	cf 01       	movw	r24, r30
    1dfc:	08 95       	ret

00001dfe <memcpy>:
    1dfe:	fb 01       	movw	r30, r22
    1e00:	dc 01       	movw	r26, r24
    1e02:	02 c0       	rjmp	.+4      	; 0x1e08 <memcpy+0xa>
    1e04:	01 90       	ld	r0, Z+
    1e06:	0d 92       	st	X+, r0
    1e08:	41 50       	subi	r20, 0x01	; 1
    1e0a:	50 40       	sbci	r21, 0x00	; 0
    1e0c:	d8 f7       	brcc	.-10     	; 0x1e04 <memcpy+0x6>
    1e0e:	08 95       	ret

00001e10 <fgetc>:
    1e10:	cf 93       	push	r28
    1e12:	df 93       	push	r29
    1e14:	ec 01       	movw	r28, r24
    1e16:	2b 81       	ldd	r18, Y+3	; 0x03
    1e18:	20 ff       	sbrs	r18, 0
    1e1a:	2f c0       	rjmp	.+94     	; 0x1e7a <fgetc+0x6a>
    1e1c:	26 ff       	sbrs	r18, 6
    1e1e:	0c c0       	rjmp	.+24     	; 0x1e38 <fgetc+0x28>
    1e20:	2f 7b       	andi	r18, 0xBF	; 191
    1e22:	2b 83       	std	Y+3, r18	; 0x03
    1e24:	8e 81       	ldd	r24, Y+6	; 0x06
    1e26:	9f 81       	ldd	r25, Y+7	; 0x07
    1e28:	01 96       	adiw	r24, 0x01	; 1
    1e2a:	9f 83       	std	Y+7, r25	; 0x07
    1e2c:	8e 83       	std	Y+6, r24	; 0x06
    1e2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e30:	90 e0       	ldi	r25, 0x00	; 0
    1e32:	df 91       	pop	r29
    1e34:	cf 91       	pop	r28
    1e36:	08 95       	ret
    1e38:	22 ff       	sbrs	r18, 2
    1e3a:	14 c0       	rjmp	.+40     	; 0x1e64 <fgetc+0x54>
    1e3c:	e8 81       	ld	r30, Y
    1e3e:	f9 81       	ldd	r31, Y+1	; 0x01
    1e40:	80 81       	ld	r24, Z
    1e42:	08 2e       	mov	r0, r24
    1e44:	00 0c       	add	r0, r0
    1e46:	99 0b       	sbc	r25, r25
    1e48:	20 62       	ori	r18, 0x20	; 32
    1e4a:	00 97       	sbiw	r24, 0x00	; 0
    1e4c:	a9 f0       	breq	.+42     	; 0x1e78 <fgetc+0x68>
    1e4e:	31 96       	adiw	r30, 0x01	; 1
    1e50:	f9 83       	std	Y+1, r31	; 0x01
    1e52:	e8 83       	st	Y, r30
    1e54:	2e 81       	ldd	r18, Y+6	; 0x06
    1e56:	3f 81       	ldd	r19, Y+7	; 0x07
    1e58:	2f 5f       	subi	r18, 0xFF	; 255
    1e5a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e5c:	3f 83       	std	Y+7, r19	; 0x07
    1e5e:	2e 83       	std	Y+6, r18	; 0x06
    1e60:	99 27       	eor	r25, r25
    1e62:	e7 cf       	rjmp	.-50     	; 0x1e32 <fgetc+0x22>
    1e64:	ea 85       	ldd	r30, Y+10	; 0x0a
    1e66:	fb 85       	ldd	r31, Y+11	; 0x0b
    1e68:	09 95       	icall
    1e6a:	97 ff       	sbrs	r25, 7
    1e6c:	f3 cf       	rjmp	.-26     	; 0x1e54 <fgetc+0x44>
    1e6e:	2b 81       	ldd	r18, Y+3	; 0x03
    1e70:	01 96       	adiw	r24, 0x01	; 1
    1e72:	31 f0       	breq	.+12     	; 0x1e80 <fgetc+0x70>
    1e74:	80 e2       	ldi	r24, 0x20	; 32
    1e76:	28 2b       	or	r18, r24
    1e78:	2b 83       	std	Y+3, r18	; 0x03
    1e7a:	8f ef       	ldi	r24, 0xFF	; 255
    1e7c:	9f ef       	ldi	r25, 0xFF	; 255
    1e7e:	d9 cf       	rjmp	.-78     	; 0x1e32 <fgetc+0x22>
    1e80:	80 e1       	ldi	r24, 0x10	; 16
    1e82:	f9 cf       	rjmp	.-14     	; 0x1e76 <fgetc+0x66>

00001e84 <fputc>:
    1e84:	0f 93       	push	r16
    1e86:	1f 93       	push	r17
    1e88:	cf 93       	push	r28
    1e8a:	df 93       	push	r29
    1e8c:	18 2f       	mov	r17, r24
    1e8e:	09 2f       	mov	r16, r25
    1e90:	eb 01       	movw	r28, r22
    1e92:	8b 81       	ldd	r24, Y+3	; 0x03
    1e94:	81 fd       	sbrc	r24, 1
    1e96:	09 c0       	rjmp	.+18     	; 0x1eaa <fputc+0x26>
    1e98:	1f ef       	ldi	r17, 0xFF	; 255
    1e9a:	0f ef       	ldi	r16, 0xFF	; 255
    1e9c:	81 2f       	mov	r24, r17
    1e9e:	90 2f       	mov	r25, r16
    1ea0:	df 91       	pop	r29
    1ea2:	cf 91       	pop	r28
    1ea4:	1f 91       	pop	r17
    1ea6:	0f 91       	pop	r16
    1ea8:	08 95       	ret
    1eaa:	82 ff       	sbrs	r24, 2
    1eac:	14 c0       	rjmp	.+40     	; 0x1ed6 <fputc+0x52>
    1eae:	2e 81       	ldd	r18, Y+6	; 0x06
    1eb0:	3f 81       	ldd	r19, Y+7	; 0x07
    1eb2:	8c 81       	ldd	r24, Y+4	; 0x04
    1eb4:	9d 81       	ldd	r25, Y+5	; 0x05
    1eb6:	28 17       	cp	r18, r24
    1eb8:	39 07       	cpc	r19, r25
    1eba:	3c f4       	brge	.+14     	; 0x1eca <fputc+0x46>
    1ebc:	e8 81       	ld	r30, Y
    1ebe:	f9 81       	ldd	r31, Y+1	; 0x01
    1ec0:	cf 01       	movw	r24, r30
    1ec2:	01 96       	adiw	r24, 0x01	; 1
    1ec4:	99 83       	std	Y+1, r25	; 0x01
    1ec6:	88 83       	st	Y, r24
    1ec8:	10 83       	st	Z, r17
    1eca:	8e 81       	ldd	r24, Y+6	; 0x06
    1ecc:	9f 81       	ldd	r25, Y+7	; 0x07
    1ece:	01 96       	adiw	r24, 0x01	; 1
    1ed0:	9f 83       	std	Y+7, r25	; 0x07
    1ed2:	8e 83       	std	Y+6, r24	; 0x06
    1ed4:	e3 cf       	rjmp	.-58     	; 0x1e9c <fputc+0x18>
    1ed6:	e8 85       	ldd	r30, Y+8	; 0x08
    1ed8:	f9 85       	ldd	r31, Y+9	; 0x09
    1eda:	81 2f       	mov	r24, r17
    1edc:	09 95       	icall
    1ede:	89 2b       	or	r24, r25
    1ee0:	a1 f3       	breq	.-24     	; 0x1eca <fputc+0x46>
    1ee2:	da cf       	rjmp	.-76     	; 0x1e98 <fputc+0x14>

00001ee4 <ungetc>:
    1ee4:	fb 01       	movw	r30, r22
    1ee6:	23 81       	ldd	r18, Z+3	; 0x03
    1ee8:	20 ff       	sbrs	r18, 0
    1eea:	11 c0       	rjmp	.+34     	; 0x1f0e <ungetc+0x2a>
    1eec:	26 fd       	sbrc	r18, 6
    1eee:	0f c0       	rjmp	.+30     	; 0x1f0e <ungetc+0x2a>
    1ef0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ef2:	98 07       	cpc	r25, r24
    1ef4:	71 f0       	breq	.+28     	; 0x1f12 <ungetc+0x2e>
    1ef6:	82 83       	std	Z+2, r24	; 0x02
    1ef8:	2f 7d       	andi	r18, 0xDF	; 223
    1efa:	20 64       	ori	r18, 0x40	; 64
    1efc:	23 83       	std	Z+3, r18	; 0x03
    1efe:	26 81       	ldd	r18, Z+6	; 0x06
    1f00:	37 81       	ldd	r19, Z+7	; 0x07
    1f02:	21 50       	subi	r18, 0x01	; 1
    1f04:	31 09       	sbc	r19, r1
    1f06:	37 83       	std	Z+7, r19	; 0x07
    1f08:	26 83       	std	Z+6, r18	; 0x06
    1f0a:	99 27       	eor	r25, r25
    1f0c:	08 95       	ret
    1f0e:	8f ef       	ldi	r24, 0xFF	; 255
    1f10:	9f ef       	ldi	r25, 0xFF	; 255
    1f12:	08 95       	ret

00001f14 <__ultoa_invert>:
    1f14:	fa 01       	movw	r30, r20
    1f16:	aa 27       	eor	r26, r26
    1f18:	28 30       	cpi	r18, 0x08	; 8
    1f1a:	51 f1       	breq	.+84     	; 0x1f70 <__ultoa_invert+0x5c>
    1f1c:	20 31       	cpi	r18, 0x10	; 16
    1f1e:	81 f1       	breq	.+96     	; 0x1f80 <__ultoa_invert+0x6c>
    1f20:	e8 94       	clt
    1f22:	6f 93       	push	r22
    1f24:	6e 7f       	andi	r22, 0xFE	; 254
    1f26:	6e 5f       	subi	r22, 0xFE	; 254
    1f28:	7f 4f       	sbci	r23, 0xFF	; 255
    1f2a:	8f 4f       	sbci	r24, 0xFF	; 255
    1f2c:	9f 4f       	sbci	r25, 0xFF	; 255
    1f2e:	af 4f       	sbci	r26, 0xFF	; 255
    1f30:	b1 e0       	ldi	r27, 0x01	; 1
    1f32:	3e d0       	rcall	.+124    	; 0x1fb0 <__ultoa_invert+0x9c>
    1f34:	b4 e0       	ldi	r27, 0x04	; 4
    1f36:	3c d0       	rcall	.+120    	; 0x1fb0 <__ultoa_invert+0x9c>
    1f38:	67 0f       	add	r22, r23
    1f3a:	78 1f       	adc	r23, r24
    1f3c:	89 1f       	adc	r24, r25
    1f3e:	9a 1f       	adc	r25, r26
    1f40:	a1 1d       	adc	r26, r1
    1f42:	68 0f       	add	r22, r24
    1f44:	79 1f       	adc	r23, r25
    1f46:	8a 1f       	adc	r24, r26
    1f48:	91 1d       	adc	r25, r1
    1f4a:	a1 1d       	adc	r26, r1
    1f4c:	6a 0f       	add	r22, r26
    1f4e:	71 1d       	adc	r23, r1
    1f50:	81 1d       	adc	r24, r1
    1f52:	91 1d       	adc	r25, r1
    1f54:	a1 1d       	adc	r26, r1
    1f56:	20 d0       	rcall	.+64     	; 0x1f98 <__ultoa_invert+0x84>
    1f58:	09 f4       	brne	.+2      	; 0x1f5c <__ultoa_invert+0x48>
    1f5a:	68 94       	set
    1f5c:	3f 91       	pop	r19
    1f5e:	2a e0       	ldi	r18, 0x0A	; 10
    1f60:	26 9f       	mul	r18, r22
    1f62:	11 24       	eor	r1, r1
    1f64:	30 19       	sub	r19, r0
    1f66:	30 5d       	subi	r19, 0xD0	; 208
    1f68:	31 93       	st	Z+, r19
    1f6a:	de f6       	brtc	.-74     	; 0x1f22 <__ultoa_invert+0xe>
    1f6c:	cf 01       	movw	r24, r30
    1f6e:	08 95       	ret
    1f70:	46 2f       	mov	r20, r22
    1f72:	47 70       	andi	r20, 0x07	; 7
    1f74:	40 5d       	subi	r20, 0xD0	; 208
    1f76:	41 93       	st	Z+, r20
    1f78:	b3 e0       	ldi	r27, 0x03	; 3
    1f7a:	0f d0       	rcall	.+30     	; 0x1f9a <__ultoa_invert+0x86>
    1f7c:	c9 f7       	brne	.-14     	; 0x1f70 <__ultoa_invert+0x5c>
    1f7e:	f6 cf       	rjmp	.-20     	; 0x1f6c <__ultoa_invert+0x58>
    1f80:	46 2f       	mov	r20, r22
    1f82:	4f 70       	andi	r20, 0x0F	; 15
    1f84:	40 5d       	subi	r20, 0xD0	; 208
    1f86:	4a 33       	cpi	r20, 0x3A	; 58
    1f88:	18 f0       	brcs	.+6      	; 0x1f90 <__ultoa_invert+0x7c>
    1f8a:	49 5d       	subi	r20, 0xD9	; 217
    1f8c:	31 fd       	sbrc	r19, 1
    1f8e:	40 52       	subi	r20, 0x20	; 32
    1f90:	41 93       	st	Z+, r20
    1f92:	02 d0       	rcall	.+4      	; 0x1f98 <__ultoa_invert+0x84>
    1f94:	a9 f7       	brne	.-22     	; 0x1f80 <__ultoa_invert+0x6c>
    1f96:	ea cf       	rjmp	.-44     	; 0x1f6c <__ultoa_invert+0x58>
    1f98:	b4 e0       	ldi	r27, 0x04	; 4
    1f9a:	a6 95       	lsr	r26
    1f9c:	97 95       	ror	r25
    1f9e:	87 95       	ror	r24
    1fa0:	77 95       	ror	r23
    1fa2:	67 95       	ror	r22
    1fa4:	ba 95       	dec	r27
    1fa6:	c9 f7       	brne	.-14     	; 0x1f9a <__ultoa_invert+0x86>
    1fa8:	00 97       	sbiw	r24, 0x00	; 0
    1faa:	61 05       	cpc	r22, r1
    1fac:	71 05       	cpc	r23, r1
    1fae:	08 95       	ret
    1fb0:	9b 01       	movw	r18, r22
    1fb2:	ac 01       	movw	r20, r24
    1fb4:	0a 2e       	mov	r0, r26
    1fb6:	06 94       	lsr	r0
    1fb8:	57 95       	ror	r21
    1fba:	47 95       	ror	r20
    1fbc:	37 95       	ror	r19
    1fbe:	27 95       	ror	r18
    1fc0:	ba 95       	dec	r27
    1fc2:	c9 f7       	brne	.-14     	; 0x1fb6 <__ultoa_invert+0xa2>
    1fc4:	62 0f       	add	r22, r18
    1fc6:	73 1f       	adc	r23, r19
    1fc8:	84 1f       	adc	r24, r20
    1fca:	95 1f       	adc	r25, r21
    1fcc:	a0 1d       	adc	r26, r0
    1fce:	08 95       	ret

00001fd0 <__ctype_isfalse>:
    1fd0:	99 27       	eor	r25, r25
    1fd2:	88 27       	eor	r24, r24

00001fd4 <__ctype_istrue>:
    1fd4:	08 95       	ret

00001fd6 <_exit>:
    1fd6:	f8 94       	cli

00001fd8 <__stop_program>:
    1fd8:	ff cf       	rjmp	.-2      	; 0x1fd8 <__stop_program>
